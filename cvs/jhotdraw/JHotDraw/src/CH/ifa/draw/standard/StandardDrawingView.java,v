head	1.30;
access;
symbols
	jhotdraw54b2-release:1.30
	reorg_6x_split:1.30
	MVC_PHASE1:1.24.0.2
	NEW_ATTRIBUTES:1.22.0.2
	DNOYEB1_ALPHA-2:1.14.4.15
	release_JHD54b1:1.19
	BUGFIX_670992:1.18.0.2
	DNOYEB1_ALPHA-1:1.14.4.11
	dnoyeb1:1.14.0.4
	repack:1.14.0.2
	Root_repack:1.14
	Before_FigureVisitor:1.12
	JHotDraw_5-3:1.8
	JHotDraw_5-2_merged:1.3
	JHotDraw_5-1_initial:1.2
	start:1.1.1.1
	vendor:1.1.1;
locks; strict;
comment	@# @;


1.30
date	2003.11.09.21.18.46;	author mrfloppy;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.23.06.38.57;	author mtnygard;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.06.07.27.42;	author pmorch;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.01.04.39.54;	author ricardo_padilha;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.25.10.21.12;	author pleumann;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.08.15.41.23;	author ricardo_padilha;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.17.19.12.11;	author dnoyeb;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.22.23.58.41;	author mrfloppy;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.11.21.10.09;	author dnoyeb;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.07.18.18.24;	author ricardo_padilha;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.03.13.11.22;	author ricardo_padilha;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.30.00.27.27;	author mrfloppy;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.12.20.21.17;	author dnoyeb;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.03.00.55.32;	author dnoyeb;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.02.19.05.40;	author dnoyeb;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.02.17.39.58;	author dnoyeb;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.27.12.02.29;	author mrfloppy;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2002.09.22.08.58.22;	author mrfloppy;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.07.22.13.59;	author mrfloppy;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.04.22.56.18;	author mrfloppy;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.20.19.57.59;	author mrfloppy;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.30.20.40.10;	author mrfloppy;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.19.18.31.32;	author mrfloppy;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.24.21.15.19;	author mrfloppy;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.20.32.01;	author mrfloppy;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.24.20.25.13;	author mrfloppy;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.29.13.42.14;	author mrfloppy;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.09.15.31.47;	author mrfloppy;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.12.16.18.06;	author jeckel;	state Exp;
branches;
next	1.1;

1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.10.12.14.57.10;	author jeckel;	state Exp;
branches;
next	;

1.14.4.1
date	2003.01.03.15.57.44;	author dnoyeb;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.01.03.16.04.00;	author dnoyeb;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.01.07.21.23.24;	author dnoyeb;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2003.01.10.04.54.45;	author dnoyeb;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2003.01.10.20.10.50;	author dnoyeb;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2003.01.13.03.14.03;	author dnoyeb;	state Exp;
branches;
next	1.14.4.7;

1.14.4.7
date	2003.01.14.18.26.27;	author dnoyeb;	state Exp;
branches;
next	1.14.4.8;

1.14.4.8
date	2003.01.16.15.59.19;	author dnoyeb;	state Exp;
branches;
next	1.14.4.9;

1.14.4.9
date	2003.01.17.21.56.06;	author dnoyeb;	state Exp;
branches;
next	1.14.4.10;

1.14.4.10
date	2003.01.20.18.23.31;	author dnoyeb;	state Exp;
branches;
next	1.14.4.11;

1.14.4.11
date	2003.01.21.00.04.39;	author dnoyeb;	state Exp;
branches;
next	1.14.4.12;

1.14.4.12
date	2003.01.26.00.51.21;	author dnoyeb;	state Exp;
branches;
next	1.14.4.13;

1.14.4.13
date	2003.01.29.04.19.50;	author dnoyeb;	state Exp;
branches;
next	1.14.4.14;

1.14.4.14
date	2003.01.29.04.25.06;	author dnoyeb;	state Exp;
branches;
next	1.14.4.15;

1.14.4.15
date	2003.01.29.23.31.55;	author dnoyeb;	state Exp;
branches;
next	;


desc
@@


1.30
log
@TestSuite: adjusting auto-generated sourcecode (JunitDoclet) to coding style
@
text
@/*
 * @@(#)StandardDrawingView.java
 *
 * Project:		JHotdraw - a GUI framework for technical drawings
 *				http://www.jhotdraw.org
 *				http://jhotdraw.sourceforge.net
 * Copyright:	? by the original author(s) and all contributors
 * License:		Lesser GNU Public License (LGPL)
 *				http://www.opensource.org/licenses/lgpl-license.html
 */

package CH.ifa.draw.standard;

import java.awt.*;
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSourceListener;
import java.awt.event.*;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.swing.JOptionPane;
import javax.swing.JPanel;

import CH.ifa.draw.contrib.AutoscrollHelper;
import CH.ifa.draw.contrib.dnd.DNDHelper;
import CH.ifa.draw.contrib.dnd.DNDInterface;
import CH.ifa.draw.framework.*;
import CH.ifa.draw.framework.Cursor;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Command;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.UndoableCommand;

/**
 * The standard implementation of DrawingView.
 *
 * @@see DrawingView
 * @@see Painter
 * @@see Tool
 *
 * @@version <$CURRENT_VERSION$>
 */
public class StandardDrawingView
		extends JPanel
		implements DrawingView, DNDInterface, java.awt.dnd.Autoscroll {

	/**
	 * The DrawingEditor of the view.
	 * @@see #tool
	 */
	transient private DrawingEditor   fEditor;

	/**
	 * the registered listeners for selection changes
	 */
	private transient List fSelectionListeners;

	/**
	 * The shown drawing.
	 */
	private Drawing         fDrawing;

	/**
	 * the accumulated damaged area
	 */
	private transient Rectangle fDamage;

	/**
	 * The list of currently selected figures.
	 */
	transient private List fSelection;

	/**
	 * The shown selection handles.
	 */
	transient private List fSelectionHandles;

	/**
	 * The preferred size of the view
	 */

	/**
	 * The position of the last mouse click
	 * inside the view.
	 */
	private Point fLastClick;

	/**
	 * A List of optional backgrounds. The list contains
	 * view painters that are drawn before the contents,
	 * that is in the background.
	 */
	private List fBackgrounds;

	/**
	 * A List of optional foregrounds. The list contains
	 * view painters that are drawn after the contents,
	 * that is in the foreground.
	 */
	private List fForegrounds;

	/**
	 * The update strategy used to repair the view.
	 */
	private Painter fUpdateStrategy;

	/**
	 * The grid used to constrain points for snap to
	 * grid functionality.
	 */
	private PointConstrainer fConstrainer;

	/**
	 * Scrolling increment
	 */
	public static final int MINIMUM_WIDTH = 400;
	public static final int MINIMUM_HEIGHT = 300;
	public static final int SCROLL_INCR = 100;
	public static final int SCROLL_OFFSET = 10;

	private static int counter;
	private int myCounter = counter;

	private DNDHelper dndh;

    /**
     * Listener for mouse clicks.
     */
    private MouseListener mouseListener;
    
    /**
     * Listener for mouse movements.
     */
    private MouseMotionListener motionListener;
    
    /**
     * Listener for the keyboard.
     */
    private KeyListener keyListener;

    /**
     * Reflects whether the drawing view is in read-only mode (from a user's
     * perspective).
     */
    private boolean myIsReadOnly;

	/*
	 * Serialization support. In JavaDraw only the Drawing is serialized.
	 * However, for beans support StandardDrawingView supports
	 * serialization
	 */
	private static final long serialVersionUID = -3878153366174603336L;
	private int drawingViewSerializedDataVersion = 1;

	/**
	 * Constructs the view.
	 */
	public StandardDrawingView(DrawingEditor editor) {
		this(editor, MINIMUM_WIDTH, MINIMUM_HEIGHT);
	}

	public StandardDrawingView(DrawingEditor editor, int width, int height) {
		setAutoscrolls(true);
		counter++;
		fEditor = editor;
		// ricardo_padilha: changed from setSize(int, int) because it is not
		// JScrollPane-friendly. 
		setPreferredSize(new Dimension(width, height));
		fSelectionListeners = CollectionsFactory.current().createList();
		addFigureSelectionListener(editor());
		setLastClick(new Point(0, 0));
		fConstrainer = null;
		fSelection = CollectionsFactory.current().createList();
		// JFC/Swing uses double buffering automatically as default
		setDisplayUpdate(createDisplayUpdate());
		// TODO: Test FastBufferedUpdateStrategy with JFC/Swing double buffering
		//setDisplayUpdate(new FastBufferedUpdateStrategy());
		setBackground(Color.lightGray);

		addMouseListener(createMouseListener());
		addMouseMotionListener(createMouseMotionListener());
		addKeyListener(createKeyListener());
    }

	protected MouseListener createMouseListener() {
        mouseListener = new DrawingViewMouseListener();
		return mouseListener;
	}

	protected MouseMotionListener createMouseMotionListener() {
        motionListener = new DrawingViewMouseMotionListener();
		return  motionListener;
	}

	protected KeyListener createKeyListener() {
        keyListener = new DrawingViewKeyListener();
		return keyListener;
	}

	/**
	 * Factory method which can be overriden by subclasses
	 */
	protected Painter createDisplayUpdate() {
		return new SimpleUpdateStrategy();
		//return new ClippingUpdateStrategy();
	}

	/**
	 * Sets the view's editor.
	 */
	public void setEditor(DrawingEditor editor) {
		fEditor = editor;
	}

	/**
	 * Gets the current tool.
	 */
	public Tool tool() {
		return editor().tool();
	}

	/**
	 * Gets the drawing.
	 */
	public Drawing drawing() {
		return fDrawing;
	}

	/**
	 * Sets and installs another drawing in the view.
	 */
	public void setDrawing(Drawing d) {
		if (drawing() != null) {
			clearSelection();
			drawing().removeDrawingChangeListener(this);
		}

		fDrawing = d;
		if (drawing() != null) {
			drawing().addDrawingChangeListener(this);
		}

		checkMinimumSize();
		repaint();
	}

	/**
	 * Gets the editor.
	 */
	public DrawingEditor editor() {
		return fEditor;
	}

	/**
	 * Adds a figure to the drawing.
	 * @@return the added figure.
	 */
	public Figure add(Figure figure) {
		return drawing().add(figure);
	}

	/**
	 * Removes a figure from the drawing.
	 * @@return the removed figure
	 */
	public Figure remove(Figure figure) {
		return drawing().remove(figure);
	}

	/**
	 * Adds a Collection of figures to the drawing.
	 */
	public void addAll(Collection figures) {
		FigureEnumeration fe = new FigureEnumerator(figures);
		while (fe.hasNextFigure()) {
			add(fe.nextFigure());
		}
	}

	/**
	 * Check existance of figure in the drawing
	 */
	public boolean figureExists(Figure inf, FigureEnumeration fe) {
		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();

			if (figure.includes(inf)) {
				return true;
			}
		}

	  return false;
	}

	/**
     * Inserts a FigureEnumeration of figures and translates them by the
	 * given offset. This function is used to insert figures from clipboards (cut/copy)
	 *
	 * @@return enumeration which has been added to the drawing. The figures in the enumeration
	 *         can have changed during adding them (e.g. they could have been decorated).
	 */
	public FigureEnumeration insertFigures(FigureEnumeration fe, int dx, int dy, boolean bCheck) {
		if (fe == null) {
			return FigureEnumerator.getEmptyEnumeration();
		}

		List vCF = CollectionsFactory.current().createList(10);
		InsertIntoDrawingVisitor visitor = new InsertIntoDrawingVisitor(drawing());

		while (fe.hasNextFigure()) {
			Figure figure = fe.nextFigure();
			if (figure instanceof ConnectionFigure) {
				vCF.add(figure);
			}
			else if (figure != null) {
				figure.moveBy(dx, dy);
				figure.visit(visitor);
			}
		}

		FigureEnumeration ecf = new FigureEnumerator(vCF);

		while (ecf.hasNextFigure()) {
			ConnectionFigure cf = (ConnectionFigure) ecf.nextFigure();
			Figure sf = cf.startFigure();
			Figure ef = cf.endFigure();

			if (figureExists(sf, drawing().figures())
				&& figureExists(ef, drawing().figures())
				&& (!bCheck || cf.canConnect(sf, ef))) {

				if (bCheck) {
					Point sp = sf.center();
					Point ep = ef.center();
					Connector fStartConnector = cf.startFigure().connectorAt(ep.x, ep.y);
					Connector fEndConnector = cf.endFigure().connectorAt(sp.x, sp.y);

					if (fEndConnector != null && fStartConnector != null) {
						cf.connectStart(fStartConnector);
						cf.connectEnd(fEndConnector);
						cf.updateConnection();
					}
				}

				cf.visit(visitor);
			}
		}

		addToSelectionAll(visitor.getInsertedFigures());
		return visitor.getInsertedFigures();
	}

	/**
	 * Returns a FigureEnumeration of connectionfigures attached to this figure
	 */
	public FigureEnumeration getConnectionFigures(Figure inFigure) {
		// If no figure or figure is non connectable, just return null
		if (inFigure == null || !inFigure.canConnect()) {
			return null;
		}

		// if (inFigure instanceof ConnectionFigure)
		//  return null;

		List result = CollectionsFactory.current().createList(5);
		FigureEnumeration figures = drawing().figures();

		// Find all connection figures
		while (figures.hasNextFigure()) {
			Figure f= figures.nextFigure();

			if ((f instanceof ConnectionFigure) && !(isFigureSelected(f))) {
				ConnectionFigure cf = (ConnectionFigure) f;

				if (cf.startFigure().includes(inFigure) || cf.endFigure().includes(inFigure)) {
					result.add(f);
				}
			}
		}

		return new FigureEnumerator(result);
   }

	/**
	 * Sets the current display update strategy.
	 * @@see Painter
	 */
	public void setDisplayUpdate(Painter updateStrategy) {
		fUpdateStrategy = updateStrategy;
	}

	/**
	 * Sets the current display update strategy.
	 * @@see Painter
	 */
	public Painter getDisplayUpdate() {
		return fUpdateStrategy;
	}

	/**
	 * Gets an enumeration over the currently selected figures.
	 * The selection is a snapshot of the current selection
	 * which does not get changed anymore
	 *
	 * @@return an enumeration with the currently selected figures.
	 */
	public FigureEnumeration selection() {
		return selectionZOrdered();
	}

	/**
	 * Gets the currently selected figures in Z order.
	 * @@see #selection
	 * @@return a FigureEnumeration with the selected figures. The enumeration
	 * represents a snapshot of the current selection.
	 */
	public FigureEnumeration selectionZOrdered() {
		List result = CollectionsFactory.current().createList(selectionCount());

		result.addAll(fSelection);
		return new ReverseFigureEnumerator(result);
	}

	/**
	 * Gets the number of selected figures.
	 */
	public int selectionCount() {
		return fSelection.size();
	}

	/**
	 * Test whether a given figure is selected.
	 */
	public boolean isFigureSelected(Figure checkFigure) {
		return fSelection.contains(checkFigure);
	}

	/**
	 * Adds a figure to the current selection. The figure is only selected if
	 * it is also contained in the Drawing associated with this DrawingView.
	 */
	public void addToSelection(Figure figure) {
		if(addToSelectionImpl(figure) == true){
			fireSelectionChanged();			
		}
	}
	protected boolean addToSelectionImpl(Figure figure){
		boolean changed = false;
		if (!isFigureSelected(figure) && drawing().includes(figure)) {
			fSelection.add(figure);
			fSelectionHandles = null;
			figure.invalidate();
			changed = true;
		}
		return changed;
	}
	/**
	 * Adds a Collection of figures to the current selection.
	 */
	public void addToSelectionAll(Collection figures) {
		addToSelectionAll(new FigureEnumerator(figures));
	}

	/**
	 * Adds a FigureEnumeration to the current selection.
	 */
	public void addToSelectionAll(FigureEnumeration fe) {
		boolean changed = false;
		while (fe.hasNextFigure()) {
			changed |= addToSelectionImpl(fe.nextFigure());
		}
		if(changed == true){
			fireSelectionChanged();
		}
	}

	/**
	 * Removes a figure from the selection.
	 */
	public void removeFromSelection(Figure figure) {
		if (isFigureSelected(figure)) {
			fSelection.remove(figure);
			fSelectionHandles = null;
			figure.invalidate();
			fireSelectionChanged();
		}
	}

	/**
	 * If a figure isn't selected it is added to the selection.
	 * Otherwise it is removed from the selection.
	 */
	public void toggleSelection(Figure figure) {
		if (isFigureSelected(figure)) {
			removeFromSelection(figure);
		}
		else {
			addToSelection(figure);
		}
		fireSelectionChanged();
	}

	/**
	 * Clears the current selection.
	 */
	public void clearSelection() {
		// there is nothing selected - bug fix ID 628818
		if (selectionCount() == 0) {
			// avoid unnecessary selection changed event when nothing has to be cleared
			return;
		}

		FigureEnumeration fe = selection();
		while (fe.hasNextFigure()) {
			fe.nextFigure().invalidate();
		}
		fSelection = CollectionsFactory.current().createList();
		fSelectionHandles = null;
		fireSelectionChanged();
	}

	/**
	 * Gets an enumeration of the currently active handles.
	 */
	protected HandleEnumeration selectionHandles() {
		if (fSelectionHandles == null) {
			fSelectionHandles = CollectionsFactory.current().createList();
			FigureEnumeration fe = selection();
			while (fe.hasNextFigure()) {
				Figure figure = fe.nextFigure();
				HandleEnumeration kk = figure.handles();
				while (kk.hasNextHandle()) {
					fSelectionHandles.add(kk.nextHandle());
				}
			}
		}
		return new HandleEnumerator(fSelectionHandles);
	}

	/**
	 * Gets the current selection as a FigureSelection. A FigureSelection
	 * can be cut, copied, pasted.
	 */
	public FigureSelection getFigureSelection() {
		return new StandardFigureSelection(selectionZOrdered(), selectionCount());
	}

	/**
	 * Finds a handle at the given coordinates.
	 * @@return the hit handle, null if no handle is found.
	 */
	public Handle findHandle(int x, int y) {
		Handle handle;

		HandleEnumeration he = selectionHandles();
		while (he.hasNextHandle()) {
			handle = he.nextHandle();
			if (handle.containsPoint(x, y)) {
				return handle;
			}
		}
		return null;
	}

	/**
	 * Informs that the current selection changed.
	 * By default this event is forwarded to the
	 * drawing editor.
	 */
	protected void fireSelectionChanged() {
		if (fSelectionListeners != null) {
			for (int i = 0; i < fSelectionListeners.size(); i++) {
				FigureSelectionListener l = (FigureSelectionListener)fSelectionListeners.get(i);
				l.figureSelectionChanged(this);
			}
		}
	}

    protected Rectangle getDamage() {
        return fDamage; // clone?
    }

    protected void setDamage(Rectangle r) {
        fDamage = r;
    }

	/**
	 * Gets the position of the last click inside the view.
	 */
	public Point lastClick() {
		return fLastClick;
	}

	protected void setLastClick(Point newLastClick) {
		fLastClick = newLastClick;
	}

	/**
	 * Sets the grid spacing that is used to constrain points.
	 */
	public void setConstrainer(PointConstrainer c) {
		fConstrainer = c;
	}

	/**
	 * Gets the current constrainer.
	 */
	public PointConstrainer getConstrainer() {
		return fConstrainer;
	}

	/**
	 * Constrains a point to the current grid.
	 */
	protected Point constrainPoint(Point p) {
		// constrain to view size
		Dimension size = getSize();
		//p.x = Math.min(size.width, Math.max(1, p.x));
		//p.y = Math.min(size.height, Math.max(1, p.y));
		p.x = Geom.range(1, size.width, p.x);
		p.y = Geom.range(1, size.height, p.y);

		if (fConstrainer != null ) {
			return fConstrainer.constrainPoint(p);
		}
		return p;
	}

	private void moveSelection(int dx, int dy) {
		FigureEnumeration figures = selection();
		while (figures.hasNextFigure()) {
			figures.nextFigure().moveBy(dx, dy);
		}
		checkDamage();
	}

	/**
	 * Refreshes the drawing if there is some accumulated damage
	 */
	public synchronized void checkDamage() {
		Iterator each = drawing().drawingChangeListeners();
		while (each.hasNext()) {
			Object l = each.next();
			if (l instanceof DrawingView) {
				((DrawingView)l).repairDamage();
			}
		}
	}

	public void repairDamage() {
		if (getDamage() != null) {
			repaint(getDamage().x, getDamage().y, getDamage().width, getDamage().height);
			setDamage(null);
		}
	}

	public void drawingInvalidated(DrawingChangeEvent e) {
		Rectangle r = e.getInvalidatedRectangle();
		if (getDamage() == null) {
			setDamage(r);
		}
		else {
			// don't manipulate rectangle returned by getDamage() directly
			// because it could be a cloned rectangle.
			Rectangle damagedR = getDamage();
			damagedR.add(r);
			setDamage(damagedR);
		}
	}

	public void drawingRequestUpdate(DrawingChangeEvent e) {
		repairDamage();
	}

	public void drawingTitleChanged(DrawingChangeEvent e){
	}

	/**
	 * Paints the drawing view. The actual drawing is delegated to
	 * the current update strategy.
	 * @@see Painter
	 */
	protected void paintComponent(Graphics g) {
		if(getDisplayUpdate() != null) {
			getDisplayUpdate().draw(g, this);
		}
	}

	/**
	 * Draws the contents of the drawing view.
	 * The view has three layers: background, drawing, handles.
	 * The layers are drawn in back to front order.
	 */
	public void drawAll(Graphics g) {
		boolean isPrinting = g instanceof PrintGraphics;
		drawBackground(g);
		if ((fBackgrounds != null) && !isPrinting) {
			drawPainters(g, fBackgrounds);
		}
		drawDrawing(g);
		if ((fForegrounds != null) && !isPrinting) {
			drawPainters(g, fForegrounds);
		}
		if (!isPrinting) {
			drawHandles(g);
		}
	}

	/**
	 * Draws the given figures.
	 * The view has three layers: background, drawing, handles.
	 * The layers are drawn in back to front order.
	 * No background is drawn.
	 */
   public void draw(Graphics g, FigureEnumeration fe) {
		boolean isPrinting = g instanceof PrintGraphics;
		//drawBackground(g);
		if ((fBackgrounds != null) && !isPrinting) {
			drawPainters(g, fBackgrounds);
		}
		drawing().draw(g, fe);
		if ((fForegrounds != null) && !isPrinting) {
			drawPainters(g, fForegrounds);
		}
		if (!isPrinting) {
			drawHandles(g);
		}
	}

	/**
	 * Draws the currently active handles.
	 */
	public void drawHandles(Graphics g) {
		HandleEnumeration he = selectionHandles();
		while (he.hasNextHandle()) {
			(he.nextHandle()).draw(g);
		}
	}

	/**
	 * Draws the drawing.
	 */
	public void drawDrawing(Graphics g) {
		drawing().draw(g);
	}

	/**
	 * Draws the background. If a background pattern is set it
	 * is used to fill the background. Otherwise the background
	 * is filled in the background color.
	 */
	public void drawBackground(Graphics g) {
		g.setColor(getBackground());
		g.fillRect(0, 0, getBounds().width, getBounds().height);
	}

	protected void drawPainters(Graphics g, List v) {
		for (int i = 0; i < v.size(); i++) {
			((Painter)v.get(i)).draw(g, this);
		}
	}

	/**
	 * Adds a background.
	 */
	public void addBackground(Painter painter)  {
		if (fBackgrounds == null) {
			fBackgrounds = CollectionsFactory.current().createList(3);
		}
		fBackgrounds.add(painter);
		repaint();
	}

	/**
	 * Removes a background.
	 */
	public void removeBackground(Painter painter)  {
		if (fBackgrounds != null) {
			fBackgrounds.remove(painter);
		}
		repaint();
	}

    protected List getBackgrounds() {
        return fBackgrounds;
    }

	/**
	 * Removes a foreground.
	 */
	public void removeForeground(Painter painter)  {
		if (fForegrounds != null) {
			fForegrounds.remove(painter);
		}
		repaint();
	}

	/**
	 * Adds a foreground.
	 */
	public void addForeground(Painter painter)  {
		if (fForegrounds == null) {
			fForegrounds = CollectionsFactory.current().createList(3);
		}
		fForegrounds.add(painter);
		repaint();
	}

    protected List getForegrounds() {
        return fForegrounds;
    }

	/**
	 * Freezes the view by acquiring the drawing lock.
	 * @@see Drawing#lock
	 */
	public void freezeView() {
		drawing().lock();
	}

	/**
	 * Unfreezes the view by releasing the drawing lock.
	 * @@see Drawing#unlock
	 */
	public void unfreezeView() {
		drawing().unlock();
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fSelection = CollectionsFactory.current().createList(); // could use lazy initialization instead
		// could use lazy initialization instead
		if (drawing() != null) {
			drawing().addDrawingChangeListener(this);
		}
		fSelectionListeners= CollectionsFactory.current().createList();
	}

    protected void checkMinimumSize() {
        Dimension d = getDrawingSize();
		Dimension v = getPreferredSize();

		if (v.height < d.height || v.width < d.width) {
			v.height = d.height + SCROLL_OFFSET;
			v.width = d.width + SCROLL_OFFSET;
			setPreferredSize(v);
        }
    }

    /**
     * Return the size of the area occupied by the contained figures inside
     * the drawing. This method is called by checkMinimumSize().
     */
    protected Dimension getDrawingSize() {
		Dimension d = new Dimension(0, 0);
		// ricardo_padilha: this test had to be introduced because a drawing view
		// can be assigned a null drawing (see setDrawing() ).
		if (drawing() != null) {
			FigureEnumeration fe = drawing().figures();
			while (fe.hasNextFigure()) {
				Rectangle r = fe.nextFigure().displayBox();
				d.width = Math.max(d.width, r.x+r.width);
				d.height = Math.max(d.height, r.y+r.height);
			}
		}
        return d;
	}

	/**
	 * @@see java.awt.Component#isFocusTraversable()
	 * @@deprecated see super class
	 */
	public boolean isFocusTraversable() {
		return true;
	}

	public boolean isInteractive() {
		return true;
	}

	public void keyTyped(KeyEvent e) {}
	public void keyReleased(KeyEvent e) {}

	/**
	 * Add a listener for selection changes.
	 * @@param fsl jhotdraw.framework.FigureSelectionListener
	 */
	public void addFigureSelectionListener(FigureSelectionListener fsl) {
		fSelectionListeners.add(fsl);
	}

	/**
	 * Remove a listener for selection changes.
	 * @@param fsl jhotdraw.framework.FigureSelectionListener
	 */
	public void removeFigureSelectionListener(FigureSelectionListener fsl) {
		fSelectionListeners.remove(fsl);
	}

	public int getDefaultDNDActions() {
		return java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE;
	}

	/***** Autoscroll support *****/
	private ASH ash = new ASH(10);

	public void autoscroll(java.awt.Point p) {
		ash.autoscroll(p);
	}
	public Insets getAutoscrollInsets() {
		return ash.getAutoscrollInsets();
	}
	class ASH extends AutoscrollHelper {
		public ASH(int margin) {
			super(margin);
		}
		public Dimension getSize() {
			return StandardDrawingView.this.getSize();
		}
		public Rectangle getVisibleRect() {
			return StandardDrawingView.this.getVisibleRect();
		}
		public void scrollRectToVisible(Rectangle aRect) {
			StandardDrawingView.this.scrollRectToVisible(aRect);
		}
	}

	public String toString() {
		return "DrawingView Nr: " + myCounter;
	}

	/**
     * Default action when any uncaught exception bubbled from
     * the mouse event handlers of the tools. Subclass may override it
     * to provide other action.
     */
    protected void handleMouseEventException(Throwable t) {
		JOptionPane.showMessageDialog(
			this,
            t.getClass().getName() + " - " + t.getMessage(),
			"Error",
			JOptionPane.ERROR_MESSAGE);
		t.printStackTrace();
    }

	public class DrawingViewMouseListener extends MouseAdapter {
		 /**
		 * Handles mouse down events. The event is delegated to the
		 * currently active tool.
		 */
		public void mousePressed(MouseEvent e) {
			try {
				requestFocus(); // JDK1.1
				Point p = constrainPoint(new Point(e.getX(), e.getY()));
				setLastClick(new Point(e.getX(), e.getY()));
				tool().mouseDown(e, p.x, p.y);
				checkDamage();
			}
			catch (Throwable t) {
				handleMouseEventException(t);
			}
		}

		/**
		 * Handles mouse up events. The event is delegated to the
		 * currently active tool.
		 */
		public void mouseReleased(MouseEvent e) {
			try {
				Point p = constrainPoint(new Point(e.getX(), e.getY()));
				tool().mouseUp(e, p.x, p.y);
				checkDamage();
			}
			catch (Throwable t) {
				handleMouseEventException(t);
			}
		}
	}

	public class DrawingViewMouseMotionListener implements MouseMotionListener {
		/**
		 * Handles mouse drag events. The event is delegated to the
		 * currently active tool.
		 */
		public void mouseDragged(MouseEvent e) {
			try {
				Point p = constrainPoint(new Point(e.getX(), e.getY()));
				tool().mouseDrag(e, p.x, p.y);
				checkDamage();
			}
			catch (Throwable t) {
				handleMouseEventException(t);
			}
		}

		/**
		 * Handles mouse move events. The event is delegated to the
		 * currently active tool.
		 */
		public void mouseMoved(MouseEvent e) {
			try {
				tool().mouseMove(e, e.getX(), e.getY());
			}
			catch (Throwable t) {
				handleMouseEventException(t);
			}
		}
	}

	public class DrawingViewKeyListener implements KeyListener {
		private Command deleteCmd;

		public DrawingViewKeyListener() {
			deleteCmd = createDeleteCommand();
		}

		/**
		 * Handles key down events. Cursor keys are handled
		 * by the view the other key events are delegated to the
		 * currently active tool.
		 */
		public void keyPressed(KeyEvent e) {
			int code = e.getKeyCode();
			// Only act on nonModified keys...
			int modifiers = e.getModifiers();
			if (modifiers == 0 &&
			    ((code == KeyEvent.VK_BACK_SPACE) ||
			     (code == KeyEvent.VK_DELETE))) {
				if (deleteCmd.isExecutable()) {
					deleteCmd.execute();
					//deleteCmd.viewSelectionChanged(this);
				}
			}
			else if (modifiers == 0 && 
				 ((code == KeyEvent.VK_DOWN)
				  || (code == KeyEvent.VK_UP)
				  || (code == KeyEvent.VK_RIGHT)
				  || (code == KeyEvent.VK_LEFT))) {
				handleCursorKey(code);
			}
			else {
				tool().keyDown(e, code);
			}
			checkDamage();
		}

		/**
		 * Handles cursor keys by moving all the selected figures
		 * one grid point in the cursor direction.
		 */
		protected void handleCursorKey(int key) {
			int dx = 0, dy = 0;
			int stepX = 1, stepY = 1;
			// should consider Null Object.
			if (fConstrainer != null) {
				stepX = fConstrainer.getStepX();
				stepY = fConstrainer.getStepY();
			}

			switch (key) {
			case KeyEvent.VK_DOWN:
				dy = stepY;
				break;
			case KeyEvent.VK_UP:
				dy = -stepY;
				break;
			case KeyEvent.VK_RIGHT:
				dx = stepX;
				break;
			case KeyEvent.VK_LEFT:
				dx = -stepX;
				break;
			}
			moveSelection(dx, dy);
		}

        public void keyTyped(KeyEvent event) {
            // do nothing
        }

        public void keyReleased(KeyEvent event) {
            // do nothing
        }

		protected Command createDeleteCommand() {
			return new UndoableCommand(new DeleteCommand("Delete", editor()));
		}
    }

	protected DNDHelper createDNDHelper() {
		return new DNDHelper(true, true) {
			protected DrawingView view() {
				return StandardDrawingView.this;
			}
			protected DrawingEditor editor() {
				return StandardDrawingView.this.editor();
			}
		};
	}

	protected DNDHelper getDNDHelper() {
		if (dndh == null) {
			dndh = createDNDHelper();
		}
		return dndh;
	}

	public DragSourceListener getDragSourceListener(){
		return getDNDHelper().getDragSourceListener();
	}

	public void DNDInitialize(DragGestureListener dgl){
		getDNDHelper().initialize(dgl);
	}

	public void DNDDeinitialize() {
		getDNDHelper().deinitialize();
	}

    /**
     * Asks whether the drawing view is in read-only mode. If so, the user can't
     * modify it using mouse or keyboard actions. Yet, it can still be modified
     * from inside the program.
     */
    public boolean isReadOnly() {
        return myIsReadOnly;
    }
    
    /**
     * Determines whether the drawing view is in read-only mode. If so, the user can't
     * modify it using mouse or keyboard actions. Yet, it can still be modified
     * from inside the program.
     */
    public void setReadOnly(boolean newIsReadOnly) {
        if (newIsReadOnly != isReadOnly()) {
            if (newIsReadOnly) {
                removeMouseListener(mouseListener);
                removeMouseMotionListener(motionListener);
                removeKeyListener(keyListener);
            }
            else {
                addMouseListener(mouseListener);
                addMouseMotionListener(motionListener);
                addKeyListener(keyListener);
            }
            
            myIsReadOnly = newIsReadOnly;
        }
    }

	/**
	 * @@see DrawingView#setCursor(Cursor)
	 * @@see java.awt.Component#setCursor(java.awt.Cursor)
	 */
	public void setCursor(Cursor cursor) {
		if (cursor instanceof java.awt.Cursor) {
			super.setCursor((java.awt.Cursor) cursor);
		}
	}

	/**
	 * Gets the minimum dimension of the drawing.<br />
	 * Fixed version (JHotDraw version has a bug).
	 * @@see StandardDrawingView#getMinimumSize()
	 * @@see java.awt.Component#getMinimumSize()
	 */
	public Dimension getMinimumSize() {
		Rectangle r = new Rectangle();
		FigureEnumeration k = drawing().figures();
		while (k.hasNextFigure()) {
			r.add(k.nextFigure().displayBox());
		}
		return new Dimension(r.width, r.height);
	}


}
@


1.29
log
@All test cases now pass!
@
text
@d148 1
a148 1
    private boolean readOnly;
d1131 2
a1132 2
    public boolean getReadOnly() {
        return readOnly;
d1140 3
a1142 3
    public void setReadOnly(boolean readOnly) {
        if (readOnly != this.readOnly) {
            if (readOnly) {
d1153 1
a1153 1
            this.readOnly = readOnly;
@


1.28
log
@Only handle KeyEvent-s for unmodified keys.
@
text
@d7 1
a7 1
 * Copyright:	© by the original author(s) and all contributors
d687 3
a689 1
		getDisplayUpdate().draw(g, this);
d1181 1
@


1.27
log
@Fixed version of getMinimumSize().
@
text
@d1028 5
a1032 1
			if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {
d1035 1
a1035 1
//					deleteCmd.viewSelectionChanged(this);
d1038 5
a1042 4
			else if ((code == KeyEvent.VK_DOWN)
					|| (code == KeyEvent.VK_UP)
					|| (code == KeyEvent.VK_RIGHT)
					|| (code == KeyEvent.VK_LEFT)) {
@


1.26
log
@StandardDrawingView can now be turned into a read-only mode, which allows it to be used for presentation purposes.
@
text
@d1160 15
@


1.25
log
@Refactoring of Cursor:
- java.awt.Cursor (class) has been sistematically replaced with CH.ifa.draw.contrib.framework.Cursor (interface)
- a new default implementation of Cursor (interface) has been added: CH.ifa.draw.contrib.standard.AWTCursor
@
text
@d129 21
d189 2
a190 1
		return new DrawingViewMouseListener();
d194 2
a195 1
		return  new DrawingViewMouseMotionListener();
d199 2
a200 1
		return new DrawingViewKeyListener();
d1118 31
@


1.24
log
@Selection event firing optimizations. per Huw Roberts
@
text
@a13 9
import CH.ifa.draw.contrib.AutoscrollHelper;
import CH.ifa.draw.contrib.dnd.DNDHelper;
import CH.ifa.draw.contrib.dnd.DNDInterface;
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Command;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.UndoableCommand;

d15 2
a22 2
import java.awt.dnd.DragGestureListener;
import java.awt.dnd.DragSourceListener;
d27 10
d1094 11
@


1.23
log
@no message
@
text
@d421 6
d431 1
a431 1
			fireSelectionChanged();
d433 1
a434 1

d446 1
d448 4
a451 1
			addToSelection(fe.nextFigure());
@


1.22
log
@DND Update.  Hopefully this allows easier DND manipulation with the added
function seperation.
@
text
@d14 9
d30 2
a35 9
import CH.ifa.draw.contrib.AutoscrollHelper;
import CH.ifa.draw.contrib.dnd.DNDHelper;
import CH.ifa.draw.contrib.dnd.DNDInterface;
import CH.ifa.draw.framework.*;
import CH.ifa.draw.util.CollectionsFactory;
import CH.ifa.draw.util.Command;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.UndoableCommand;

d46 2
a47 2
	extends JPanel
	implements DrawingView, DNDInterface, java.awt.dnd.Autoscroll {
d53 1
a53 1
	transient private DrawingEditor fEditor;
d63 1
a63 1
	private Drawing fDrawing;
a82 6
	/*
	 * ricardo_padilha: this was removed because it interferes with proper
	 * handling of sizes in Swing. For example, it prevents JScrollPane to receive
	 * events about the changes of preferred and minimum sizes.
	 */
	//private Dimension fViewSize;
d164 1
a164 1
	}
d171 1
a171 1
		return new DrawingViewMouseMotionListener();
d270 1
a270 1
		return false;
d274 1
a274 1
	   * Inserts a FigureEnumeration of figures and translates them by the
d280 1
a280 5
	public FigureEnumeration insertFigures(
		FigureEnumeration fe,
		int dx,
		int dy,
		boolean bCheck) {
d292 2
a293 1
			} else if (figure != null) {
d348 1
a348 1
			Figure f = figures.nextFigure();
d360 1
a360 1
	}
a397 10
		// why do this? why not just take the vector fSelection?
		/*FigureEnumeration figures = drawing().figures();
		
		while (figures.hasNextFigure()) {
			Figure f= figures.nextFigure();
			if (isFigureSelected(f)) {
				result.add(f);
			}
		}*/

d464 2
a465 1
		} else {
d541 1
a541 1
				FigureSelectionListener l = (FigureSelectionListener) fSelectionListeners.get(i);
d547 7
a553 7
	protected Rectangle getDamage() {
		return fDamage; // clone?
	}

	protected void setDamage(Rectangle r) {
		fDamage = r;
	}
d591 1
a591 1
		if (fConstrainer != null) {
d613 1
a613 1
				((DrawingView) l).repairDamage();
d629 2
a630 1
		} else {
d643 1
a643 1
	public void drawingTitleChanged(DrawingChangeEvent e) {
d681 1
a681 1
	public void draw(Graphics g, FigureEnumeration fe) {
d725 1
a725 1
			((Painter) v.get(i)).draw(g, this);
d732 1
a732 1
	public void addBackground(Painter painter) {
d743 1
a743 1
	public void removeBackground(Painter painter) {
d750 3
a752 3
	protected List getBackgrounds() {
		return fBackgrounds;
	}
d757 1
a757 1
	public void removeForeground(Painter painter) {
d767 1
a767 1
	public void addForeground(Painter painter) {
d775 3
a777 3
	protected List getForegrounds() {
		return fForegrounds;
	}
d800 1
a800 1
		fSelection = CollectionsFactory.current().createList();
d805 1
a805 1
		fSelectionListeners = CollectionsFactory.current().createList();
d808 2
a809 2
	protected void checkMinimumSize() {
		Dimension d = getDrawingSize();
d816 2
a817 2
		}
	}
d819 5
a823 5
	/**
	 * Return the size of the area occupied by the contained figures inside
	 * the drawing. This method is called by checkMinimumSize().
	 */
	protected Dimension getDrawingSize() {
d831 2
a832 2
				d.width = Math.max(d.width, r.x + r.width);
				d.height = Math.max(d.height, r.y + r.height);
d835 1
a835 1
		return d;
d850 2
a851 4
	public void keyTyped(KeyEvent e) {
	}
	public void keyReleased(KeyEvent e) {
	}
d902 5
a906 5
	   * Default action when any uncaught exception bubbled from
	   * the mouse event handlers of the tools. Subclass may override it
	   * to provide other action.
	   */
	protected void handleMouseEventException(Throwable t) {
d909 1
a909 1
			t.getClass().getName() + " - " + t.getMessage(),
d913 1
a913 1
	}
d916 4
a919 4
		/**
		* Handles mouse down events. The event is delegated to the
		* currently active tool.
		*/
d927 2
a928 1
			} catch (Throwable t) {
d942 2
a943 1
			} catch (Throwable t) {
d959 2
a960 1
			} catch (Throwable t) {
d972 2
a973 1
			} catch (Throwable t) {
d996 1
a996 1
					//					deleteCmd.viewSelectionChanged(this);
d998 2
a999 2
			} else if (
				(code == KeyEvent.VK_DOWN)
d1004 2
a1005 1
			} else {
d1025 12
a1036 12
				case KeyEvent.VK_DOWN :
					dy = stepY;
					break;
				case KeyEvent.VK_UP :
					dy = -stepY;
					break;
				case KeyEvent.VK_RIGHT :
					dx = stepX;
					break;
				case KeyEvent.VK_LEFT :
					dx = -stepX;
					break;
d1041 7
a1047 7
		public void keyTyped(KeyEvent event) {
			// do nothing
		}

		public void keyReleased(KeyEvent event) {
			// do nothing
		}
d1052 1
a1052 1
	}
d1055 8
a1062 9
		DNDHelper dndh = new DNDHelper (true,true) {
				protected DrawingView view() {
					return StandardDrawingView.this;
				}
				protected DrawingEditor editor() {
					return StandardDrawingView.this.editor();
				}
			};
		return dndh;
d1071 2
a1072 1
	public java.awt.dnd.DragSourceListener getDragSourceListener(){
d1075 2
a1076 1
	public void DNDInitialize(java.awt.dnd.DragGestureListener dgl){
d1079 1
@


1.21
log
@Improved handling of sizes.
The proprietary handling of the component size was replaced by the standard mechanism provided by the JDK.
@
text
@d1067 9
a1075 5
		return new DNDHelper() {
			protected DrawingView view() {
				return StandardDrawingView.this;
			}
		};
d1084 5
a1088 3

	public boolean setDragSourceActive(boolean state) {
		return getDNDHelper().setDragSourceActive(state);
d1090 2
a1091 3

	public boolean setDropTargetActive(boolean state) {
		return getDNDHelper().setDropTargetActive(state);
@


1.20
log
@Fixed Javadocs in "isFocusTransversable" to avoid "deprecated" warnings.
Reorganized imports.
@
text
@d44 2
a45 3
		extends JPanel
		implements DrawingView,
		DNDInterface, java.awt.dnd.Autoscroll {
d51 1
a51 1
	transient private DrawingEditor   fEditor;
d61 1
a61 1
	private Drawing         fDrawing;
d81 6
a86 1
	private Dimension fViewSize;
d151 3
a153 2
		fViewSize = new Dimension(width,height);
		setSize(width, height);
d175 1
a175 1
		return  new DrawingViewMouseMotionListener();
d274 1
a274 1
	  return false;
d278 1
a278 1
     * Inserts a FigureEnumeration of figures and translates them by the
d284 5
a288 1
	public FigureEnumeration insertFigures(FigureEnumeration fe, int dx, int dy, boolean bCheck) {
d300 1
a300 2
			}
			else if (figure != null) {
d313 3
a315 3
			if (figureExists(sf, drawing().figures()) &&
				figureExists(ef, drawing().figures()) &&
				(!bCheck || cf.canConnect(sf, ef))) {
d355 1
a355 1
			Figure f= figures.nextFigure();
d360 1
a360 2
				if (cf.startFigure().includes(inFigure) ||
					cf.endFigure().includes(inFigure)) {
a366 14
   }

	/**
	 * Gets the minimum dimension of the drawing.
	 */
	public Dimension getMinimumSize() {
		return fViewSize;
	}

	/**
	 * Gets the preferred dimension of the drawing..
	 */
	public Dimension getPreferredSize() {
		return getMinimumSize();
a403 1
		FigureEnumeration figures = drawing().figures();
d405 3
d413 3
a415 1
		}
d481 1
a481 2
		}
		else {
d557 1
a557 1
				FigureSelectionListener l = (FigureSelectionListener)fSelectionListeners.get(i);
d563 7
a569 7
    protected Rectangle getDamage() {
        return fDamage; // clone?
    }

    protected void setDamage(Rectangle r) {
        fDamage = r;
    }
d607 1
a607 1
		if (fConstrainer != null ) {
d629 1
a629 1
				((DrawingView)l).repairDamage();
d645 1
a645 2
		}
		else {
d658 1
a658 1
	public void drawingTitleChanged(DrawingChangeEvent e){
d696 1
a696 1
   public void draw(Graphics g, FigureEnumeration fe) {
d740 1
a740 1
			((Painter)v.get(i)).draw(g, this);
d747 1
a747 1
	public void addBackground(Painter painter)  {
d758 1
a758 1
	public void removeBackground(Painter painter)  {
d765 3
a767 3
    protected List getBackgrounds() {
        return fBackgrounds;
    }
d772 1
a772 1
	public void removeForeground(Painter painter)  {
d782 1
a782 1
	public void addForeground(Painter painter)  {
d790 3
a792 3
    protected List getForegrounds() {
        return fForegrounds;
    }
d815 2
a816 1
		fSelection = CollectionsFactory.current().createList(); // could use lazy initialization instead
d820 1
a820 1
		fSelectionListeners= CollectionsFactory.current().createList();
d823 10
a832 2
    protected void checkMinimumSize() {
        Dimension d = getDrawingSize();
d834 5
a838 13
        if (fViewSize.height < d.height || fViewSize.width < d.width) {
            fViewSize.height = d.height + SCROLL_OFFSET;
            fViewSize.width = d.width + SCROLL_OFFSET;
            setSize(fViewSize);
        }
    }

    /**
     * Return the size of the area occupied by the contained figures inside
     * the drawing. This method is called by checkMinimumSize().
     */
    protected Dimension getDrawingSize() {
		FigureEnumeration fe = drawing().figures();
d840 9
a848 4
		while (fe.hasNextFigure()) {
			Rectangle r = fe.nextFigure().displayBox();
			d.width = Math.max(d.width, r.x+r.width);
			d.height = Math.max(d.height, r.y+r.height);
d850 1
a850 1
        return d;
d865 4
a868 2
	public void keyTyped(KeyEvent e) {}
	public void keyReleased(KeyEvent e) {}
a889 1

d919 10
a928 8
     * Default action when any uncaught exception bubbled from
     * the mouse event handlers of the tools. Subclass may override it
     * to provide other action.
     */
    protected void handleMouseEventException(Throwable t) {
        JOptionPane.showMessageDialog(this,
            t.getClass().getName() + " - " + t.getMessage(),
            "Error", JOptionPane.ERROR_MESSAGE);
d930 1
a930 1
    }
d933 4
a936 4
		 /**
		 * Handles mouse down events. The event is delegated to the
		 * currently active tool.
		 */
d944 1
a944 2
			}
			catch (Throwable t) {
d958 1
a958 2
			}
			catch (Throwable t) {
d974 1
a974 2
			}
			catch (Throwable t) {
d986 1
a986 2
			}
			catch (Throwable t) {
d1009 1
a1009 1
//					deleteCmd.viewSelectionChanged(this);
d1011 5
a1015 3
			}
			else if ((code == KeyEvent.VK_DOWN) || (code == KeyEvent.VK_UP)
					|| (code == KeyEvent.VK_RIGHT) || (code == KeyEvent.VK_LEFT)) {
d1017 1
a1017 2
			}
			else {
d1037 12
a1048 12
			case KeyEvent.VK_DOWN:
				dy = stepY;
				break;
			case KeyEvent.VK_UP:
				dy = -stepY;
				break;
			case KeyEvent.VK_RIGHT:
				dx = stepX;
				break;
			case KeyEvent.VK_LEFT:
				dx = -stepX;
				break;
d1053 7
a1059 7
        public void keyTyped(KeyEvent event) {
            // do nothing
        }

        public void keyReleased(KeyEvent event) {
            // do nothing
        }
d1064 1
a1064 1
    }
d1067 5
a1071 5
		return new DNDHelper () {
				protected DrawingView view() {
					return StandardDrawingView.this;
				}
			};
@


1.19
log
@prepare for 5.4 release: various bug fixes
@
text
@d14 11
a25 1
import CH.ifa.draw.contrib.ClippingUpdateStrategy;
a27 1
import CH.ifa.draw.util.*;
d29 4
a32 6
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.io.*;
d852 4
@


1.18
log
@Clean up head to be what it was before i mistakenly committed my changes to it.
My changes should have been committed to a branch, and let mrfloppy merge to the trunk.
This will happen from now on.
@
text
@d15 1
d175 1
d506 1
a506 1
	private HandleEnumeration selectionHandles() {
d654 3
@


1.17
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d134 2
a135 1
	public StandardDrawingView(Drawing drawing, DrawingEditor editor, int width, int height) {
a154 4
        setDrawing(drawing);
    }
	public StandardDrawingView(DrawingEditor editor, int width, int height) {
        this(new StandardDrawing(),editor,width,height);
d653 1
a653 2
    public void drawingTitleChanged(DrawingChangeEvent e){
    }
@


1.16
log
@bug 541524, 546628,547188
Improved Desktop functionality

This is an extra commit because NetBeans left off my comments
@
text
@d656 2
a657 1

@


1.15
log
@
Changes for better Desktop handling.
Always has a Drawing.
@
text
@@


1.14
log
@bug fix for Sourceforge-bug-id 628818
@
text
@d134 1
a134 2

	public StandardDrawingView(DrawingEditor editor, int width, int height) {
d154 4
@


1.14.4.1
log
@Changes for better Desktop handling.
DrawingView Always has a Drawing.
bug 541524, 546628,547188
@
text
@d134 2
a135 1
	public StandardDrawingView(Drawing drawing, DrawingEditor editor, int width, int height) {
a154 4
        setDrawing(drawing);
    }
	public StandardDrawingView(DrawingEditor editor, int width, int height) {
        this(new StandardDrawing(),editor,width,height);
@


1.14.4.2
log
@Improved drawing and application title handling.
MDI was not setting activeDrawingView to null when last was closed.
New drawingTitleChange event.
@
text
@d656 1
a656 2
    public void drawingTitleChanged(DrawingChangeEvent e){
    }
@


1.14.4.3
log
@1. Added getDesktop to the DrawingEditor.  added null returns to all Classes that dont fully support
   the Desktop architecture yet, like the applets.

2. Added a figureSelection listener to the DrawingEditor so one can register with the DrawingEditor to
   hear figure selection events.  You can still register with the individual DrawingViews if you wish.
   The DrawingEditor will guarantee that it only fires this event on the active view, so it saves a listener
   from having to register and unregister with views to hear this event each time the activeView changes.
   All Commands were doing this register/unregister dance.

3. AbstractCommand now registers for figureSelectionEvents with the drawingEditor as opposed to the
   DrawingView.

4. Went back to viewCreated and viewDestroying naming.  flip flopping.  Its actually more accurate.  the
   real issue is that 2 events are missing, viewDestroyed and viewCreating.  dont need them yet, but
   they may materialize in the future.

5. Went back to Tool CompositeTool being enabled even when no figure is selected.

6. FigureSelectionListener now extends java.util.EventListener now because I am too lazy to write
   an event handler just yet.

7. implemented new findFigureInside() fix.  needs testing.

8. standardDrawingView selectionZordered now returns figures in the proper order(not reversed).
@
text
@d413 1
a413 1
		return new FigureEnumerator(result);
@


1.14.4.4
log
@1.  Tool now accepts DrawingViewMouseEvent as opposed to java.awt.MouseEvent and x,y ints.
2. compositeFigure now uses constrained mouse values throughout.
3. nested CreationTOol was calling drawing() before it was setting the view.  should lead to NPE.  this tool still seems broken
   i dont think its needed anymore?
4. bug in splitConnectionTool mouse down. setEndConnector(findConnector(ex, ex, c)); needs to be ex and ey
5. made some of StandardDrawingViews inner class listners protected.
@
text
@d161 1
a161 1
		return new innerDrawingViewMouseListener();
d165 1
a165 1
		return  new innerDrawingViewMouseMotionListener();
d169 1
a169 1
		return new innerDrawingViewKeyListener();
d916 1
a916 1
	protected class innerDrawingViewMouseListener extends MouseAdapter {
d925 2
a926 2
				setLastClick(new Point(e.getX(), e.getY())); //technically a click is a down and up event, not just down
				tool().mouseDown(new DrawingViewMouseEvent(StandardDrawingView.this,e,p.x, p.y));
d941 1
a941 1
				tool().mouseUp(new DrawingViewMouseEvent(StandardDrawingView.this,e,p.x, p.y) );
d950 1
a950 1
	protected class innerDrawingViewMouseMotionListener implements MouseMotionListener {
d958 1
a958 1
				tool().mouseDrag(new DrawingViewMouseEvent(StandardDrawingView.this,e,p.x, p.y) );
d972 1
a972 2
				Point p = constrainPoint(new Point(e.getX(), e.getY()));
				tool().mouseMove(new DrawingViewMouseEvent(StandardDrawingView.this,e,p.x, p.y) );
d980 1
a980 1
	protected class innerDrawingViewKeyListener implements KeyListener {
d983 1
a983 1
		public innerDrawingViewKeyListener() {
@


1.14.4.5
log
@DND now 'almost' implements Undo/Redo.
It works but its 2 seperate actions, so it takes 2 actions to undo
and 2 actions to redo.  havent found out how to remedy this yet.
Since the Drag gesture may be different on different platforms one must
either implement a JHD drag gesture recognizer, which is not the correct approach.
Or one must make the tool sufficietly generic to handle and undo drags from all platforms.

shooting for the latter.  DND needs some work.  But its still working.
@
text
@a103 2
	 * Should generalize this to a Constrainer interface.  may have more reasons
	 * for constraint than just grid.
a1057 3
				}
				protected DrawingEditor editor() {
					return StandardDrawingView.this.editor();
@


1.14.4.6
log
@1. javadoc comments and corrections and clarifications
2. Drawing no longer exposes its drawing change listener, but has a method for those who want the drawing to request all views of it to be updated.
3. all removeAll() methods in CompositeFigure now have single consistent implementation.
4. standardDrawing unlock calls notify instead of notifyAll since only 1 can grab the lock anyway.
@
text
@a622 4
	 * This is typically called when a Tool/Command has finished its editing
	 * manoever and wants those observing the underlying drawing to update
	 * themselves.  Sort of a finished editing-action notification.
	 * @@see Drawing#update()
d625 7
a631 1
		drawing().update();
@


1.14.4.7
log
@DecoratorFigure is 'changed'  I think it needs reworking.  not its only used durint draw(Graphics g) but I don't think
that was its real intention?

The Figure added or removed is nolonger changed during the add or remove process.  Thus add and remove do not return
values.
orphan is used internally to the drawing only.
remove calls figure.remove() which intern orphans the figure.
remove(Figure f) is still present and used but currently not needed.  call figure.remove() instead.
perhaps we can add a method on the figure enumerator to 'remove' all the figures within it.
Figure no longer exposes its listeners.  call methods on figure to send events.


Serialization in every form needs cleanup now.  Some due to earlier changes made by myself like making listeners of
inner classes, but not storing the listener when the figures are stored. (since the figures think the inner listener
is their container.)
@
text
@d229 1
d231 2
a232 2
	public void add(Figure figure) {
		drawing().add(figure);
d237 1
d239 2
a240 2
	public void remove(Figure figure) {
		drawing().remove(figure);
@


1.14.4.8
log
@drawing.update() is called as opposed to view.checkDamage().  This causes all affected views
to be updated as opposed to just the one.
figure.Remove() now returns the container it was removed from.  This may assist undo/redo.
@
text
@d616 1
a616 1
		checkDamage();//likely unneeded, the Tool should request the update !!!dnoyeb!!!
a623 2
	 * But this is based on damage to the view and not damage to the drawing.
	 * Overagressive in updating other views when not necessary. drawing.update updates all views.
@


1.14.4.9
log
@view addToSelection used drawing.includes(figure) but selectionZOrdered uses figures()
these are 2 different sets of figures.  changed addToSelection to use containsFigure()
Added some experimental copy constructors that are not being used.
some trivial comments.
@
text
@d435 1
a435 1
		if (!isFigureSelected(figure) && drawing().containsFigure(figure)) {
@


1.14.4.10
log
@More cleanups for DecoratorFigure.  Its going to cause problems till the architecture changes.
Added a few needed methods to expose private variables of StandardDrawingView to make it more
override friendly.
@
text
@d442 1
a442 13
	protected final List getSelection(){
		return fSelection;
	}
	protected final void setSelection(List list){
		fSelection = list;
	}
	protected final List getSelectionHandles(){
		return fSelectionHandles;
	}
	protected final void setSelectionHandles(List list){
		fSelectionHandles = list;
	}
 	
@


1.14.4.11
log
@Restored the ContainerFigure.  Its very problematic for tools, but I have a better understanding of the undo system now.
As a result I have restored most of what was their again with explanations on how it works for the next traveler...
Also fixed a few issues with grouping and ungrouping. since figures can no longer be in 2 containers at once the container
hopping that was being done by the group command would fail.  I believe border tool did similar hopping by having a figure
as part of the drawing and part of the borderFigure temporarily.  Cant do that anymore.
@
text
@d230 2
a231 2
	public Figure add(Figure figure) {
		return drawing().add(figure);
d237 2
a238 2
	public Figure remove(Figure figure) {
		return drawing().remove(figure);
d244 1
a244 1
	public FigureEnumeration addAll(Collection figures) {
a245 1
		List l = CollectionsFactory.current().createList();
d247 1
a247 1
			l.add(add(fe.nextFigure()));
a248 1
		return new FigureEnumerator(l);
@


1.14.4.12
log
@CompositeFigure does not return figures from add, remove, orphan anymore
new method, restore added to bring back orphaned figures
compositeFigure keeps record of its orphans for the restore method
NullFigures inserted as placeholders into the figureList
dumps record and nullFigures when remove(figure) called. this safely restores
figures to their old places.
figureRequestRemove and figureRemove events eliminated.
Group and Ungroup commands redone to respect these new ideas.
have not done anything with delete, cut, copy, paste yet.
NullFigure added 0,0 for its display box, else throwing exceptions
@
text
@d230 2
a231 2
	public void add(Figure figure) {
		drawing().add(figure);
d237 2
a238 2
	public void remove(Figure figure) {
		drawing().remove(figure);
d244 1
a244 1
	public void addAll(Collection figures) {
d246 1
d248 1
a248 1
			add(fe.nextFigure());
d250 1
@


1.14.4.13
log
@DND Improvements in OO and Efficiency
@
text
@d1067 1
a1067 1
		DNDHelper dndh = new DNDHelper () {
a1073 6
				protected boolean isDropTarget(){
					return true;
				}
				protected boolean isDragSource(){
					return true;
				}
a1074 1
		return dndh;
d1083 3
a1085 8
	public java.awt.dnd.DragSourceListener getDragSourceListener(){
		return getDNDHelper().getDragSourceListener();
	}
	public void DNDInitialize(java.awt.dnd.DragGestureListener dgl){
		getDNDHelper().initialize(dgl);
	}
	public void DNDDeinitialize() {
		getDNDHelper().deinitialize();
d1088 2
a1089 2
	public void setDragSourceState(boolean state) {
		getDNDHelper().setDragSourceState(state);
@


1.14.4.14
log
@DND
@
text
@d1100 3
a1102 3
//	public void setDragSourceState(boolean state) {
//		getDNDHelper().setDragSourceState(state);
//	}
@


1.14.4.15
log
@Dnd rework
@
text
@d1067 1
a1067 1
		DNDHelper dndh = new DNDHelper (true,true) {
d1073 6
@


1.13
log
@introduce FigureVisitor for paste/delete commands
@
text
@d486 2
a487 2
		// there is nothing selected
		if (fSelectionHandles == null) {
@


1.12
log
@bug fix 594961
@
text
@a274 1
		List addedFigures = CollectionsFactory.current().createList();
d276 1
d285 1
a285 4
				figure = add(figure);
				addToSelection(figure);
				// figure might has changed during adding so add it afterwards
				addedFigures.add(figure);
d313 1
a313 4
				Figure nf = add(cf);
				addToSelection(nf);
				// figure might has changed during adding so add it afterwards
				addedFigures.add(nf);
d317 2
a318 1
		return new FigureEnumerator(addedFigures);
@


1.11
log
@after variou merges... (before 5.4 release)
@
text
@d982 6
d996 3
a998 4
				Command cmd = new DeleteCommand("Delete", editor());
				if (cmd.isExecutable()) {
					cmd.execute();
//					cmd.viewSelectionChanged(this);
d1048 4
@


1.10
log
@various merges (TextArea, HTMLTextArea, CreationTool, MiniMap, bug fixes)
@
text
@d15 2
d23 1
a34 1

d38 1
a38 1
				   java.awt.dnd.Autoscroll {
a42 1
	 * @@see #setStatus
d49 1
a49 1
	private transient Vector fSelectionListeners;
d64 1
a64 1
	transient private Vector fSelection;
d69 1
a69 1
	transient private Vector fSelectionHandles;
d83 2
a84 2
	 * A vector of optional backgrounds. The vector maintains
	 * a list a view painters that are drawn before the contents,
d87 1
a87 1
	private Vector fBackgrounds;
d90 2
a91 2
	 * A vector of optional foregrounds. The vector maintains
	 * a list a view painters that are drawn after the contents,
d94 1
a94 1
	private Vector fForegrounds;
d118 2
d141 1
a141 1
		fSelectionListeners = new Vector();
d145 1
a145 1
		fSelection = new Vector();
d239 1
a239 1
	 * Adds a vector of figures to the drawing.
d241 4
a244 4
	public void addAll(Vector figures) {
		FigureEnumeration k = new FigureEnumerator(figures);
		while (k.hasMoreElements()) {
			add(k.nextFigure());
d251 3
a253 3
	public boolean figureExists(Figure inf, FigureEnumeration e) {
		while(e.hasMoreElements()) {
			Figure figure = e.nextFigure();
d255 1
a255 1
			if(figure.includes(inf)) {
d275 2
a276 2
		Vector addedFigures = new Vector();
		Vector vCF = new Vector(10);
d278 1
a278 1
		while (fe.hasMoreElements()) {
d281 1
a281 1
				vCF.addElement(figure);
d288 1
a288 1
				addedFigures.addElement(figure);
d294 1
a294 1
		while (ecf.hasMoreElements()) {
d319 1
a319 1
				addedFigures.addElement(nf);
d327 1
a327 1
	 * Returns a vector of connectionfigures attached to this figure
d329 1
a329 1
	public Vector getConnectionFigures(Figure inFigure) {
d338 1
a338 1
		Vector result = new Vector(5);
d342 1
a342 1
		while (figures.hasMoreElements()) {
d350 1
a350 1
					result.addElement(f);
d355 1
a355 1
		return result;
a388 10
	 * Gets the currently selected figures.
	 * @@return a vector with the selected figures. The vector
	 * is a copy of the current selection.
	 */
	public Vector selection() {
		// protect the vector with the current selection
		return (Vector)fSelection.clone();
	}

	/**
d390 4
d395 2
a396 2
	public FigureEnumeration selectionElements() {
		return new FigureEnumerator(selectionZOrdered());
d402 2
a403 2
	 * @@return a vector with the selected figures. The vector
	 * is a copy of the current selection.
d405 2
a406 2
	public Vector selectionZOrdered() {
		Vector result = new Vector(selectionCount());
d409 1
a409 1
		while (figures.hasMoreElements()) {
d412 1
a412 1
				result.addElement(f);
d415 1
a415 1
		return result;
d438 1
a438 1
			fSelection.addElement(figure);
d446 1
a446 1
	 * Adds a vector of figures to the current selection.
d448 1
a448 1
	public void addToSelectionAll(Vector figures) {
d456 1
a456 1
		while (fe.hasMoreElements()) {
d466 1
a466 1
			fSelection.removeElement(figure);
d497 2
a498 2
		FigureEnumeration fe = selectionElements();
		while (fe.hasMoreElements()) {
d501 1
a501 1
		fSelection = new Vector();
d509 1
a509 1
	private Enumeration selectionHandles() {
d511 7
a517 7
			fSelectionHandles = new Vector();
			FigureEnumeration k = selectionElements();
			while (k.hasMoreElements()) {
				Figure figure = k.nextFigure();
				Enumeration kk = figure.handles().elements();
				while (kk.hasMoreElements()) {
					fSelectionHandles.addElement(kk.nextElement());
d521 1
a521 1
		return fSelectionHandles.elements();
d529 1
a529 1
		return new StandardFigureSelection(new FigureEnumerator(selectionZOrdered()), selectionCount());
d539 3
a541 3
		Enumeration k = selectionHandles();
		while (k.hasMoreElements()) {
			handle = (Handle) k.nextElement();
d557 1
a557 1
				FigureSelectionListener l = (FigureSelectionListener)fSelectionListeners.elementAt(i);
d564 1
a564 1
        return fDamage;
d614 2
a615 2
		FigureEnumeration figures = selectionElements();
		while (figures.hasMoreElements()) {
d625 3
a627 3
		Enumeration each = drawing().drawingChangeListeners();
		while (each.hasMoreElements()) {
			Object l = each.nextElement();
d713 3
a715 3
		Enumeration k = selectionHandles();
		while (k.hasMoreElements()) {
			((Handle) k.nextElement()).draw(g);
d736 1
a736 1
	protected void drawPainters(Graphics g, Vector v) {
d738 1
a738 1
			((Painter)v.elementAt(i)).draw(g, this);
d747 1
a747 1
			fBackgrounds = new Vector(3);
d749 1
a749 1
		fBackgrounds.addElement(painter);
d758 1
a758 1
			fBackgrounds.removeElement(painter);
d763 1
a763 1
    protected Vector getBackgrounds() {
d772 1
a772 1
			fForegrounds.removeElement(painter);
d782 1
a782 1
			fForegrounds = new Vector(3);
d784 1
a784 1
		fForegrounds.addElement(painter);
d788 1
a788 1
    protected Vector getForegrounds() {
d813 1
a813 1
		fSelection = new Vector(); // could use lazy initialization instead
d817 1
a817 1
		fSelectionListeners= new Vector();
d835 1
a835 1
		FigureEnumeration k = drawing().figures();
d837 2
a838 2
		while (k.hasMoreElements()) {
			Rectangle r = k.nextFigure().displayBox();
d914 1
a920 1
		 * @@return whether the event was handled.
a937 1
		 * @@return whether the event was handled.
a954 1
		 * @@return whether the event was handled.
a969 1
		 * @@return whether the event was handled.
a985 1
		 * @@return whether the event was handled.
d1044 23
@


1.9
log
@no message
@
text
@d114 3
d137 1
d140 1
a140 1
		fLastClick = new Point(0, 0);
d566 8
d581 4
a615 1

d638 3
a640 3
		if (fDamage != null) {
			repaint(fDamage.x, fDamage.y, fDamage.width, fDamage.height);
			fDamage = null;
d646 2
a647 2
		if (fDamage == null) {
			fDamage = r;
d650 5
a654 1
			fDamage.add(r);
d739 1
a739 1
	private void drawPainters(Graphics g, Vector v) {
d766 4
d791 4
d823 15
a837 1
	private void checkMinimumSize() {
d845 1
a845 5
		if (fViewSize.height < d.height || fViewSize.width < d.width) {
			fViewSize.height = d.height + SCROLL_OFFSET;
			fViewSize.width = d.width + SCROLL_OFFSET;
			setSize(fViewSize);
		}
d908 10
a917 2
	static int counter;
	int myCounter = counter;
d926 10
a935 5
			requestFocus(); // JDK1.1
			Point p = constrainPoint(new Point(e.getX(), e.getY()));
			fLastClick = new Point(e.getX(), e.getY());
			tool().mouseDown(e, p.x, p.y);
			checkDamage();
d944 8
a951 3
			Point p = constrainPoint(new Point(e.getX(), e.getY()));
			tool().mouseUp(e, p.x, p.y);
			checkDamage();
d962 8
a969 3
			Point p = constrainPoint(new Point(e.getX(), e.getY()));
			tool().mouseDrag(e, p.x, p.y);
			checkDamage();
d978 6
a983 1
			tool().mouseMove(e, e.getX(), e.getY());
@


1.8
log
@no message
@
text
@d15 2
a21 2
import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;
d33 1
a33 1
public  class StandardDrawingView
a35 1
				   KeyListener,
d49 1
a49 1
	
d58 1
a58 1
	private transient Rectangle fDamage = null;
d86 1
a86 1
	private Vector fBackgrounds = null;
d93 1
a93 1
	private Vector fForegrounds = null;
d113 1
a113 1
	 
d128 1
a128 1
	
d131 1
a131 1
counter++;
d140 1
a140 1
		setDisplayUpdate(new SimpleUpdateStrategy());
d145 7
a151 3
		addMouseListener(ml);
		addMouseMotionListener(mml);
		addKeyListener(this);
d154 3
a156 28
	MouseListener ml = new MouseListener() {
		// listener methods we are not interested in
		public void mouseClicked(MouseEvent e) {}
		public void mouseEntered(MouseEvent e) {}
		public void mouseExited(MouseEvent e) {}
		 /**
		 * Handles mouse down events. The event is delegated to the
		 * currently active tool.
		 * @@return whether the event was handled.
		 */
		public void mousePressed(MouseEvent e) {
			requestFocus(); // JDK1.1
			Point p = constrainPoint(new Point(e.getX(), e.getY()));
			fLastClick = new Point(e.getX(), e.getY());
			tool().mouseDown(e, p.x, p.y);
			checkDamage();
		}
		/**
		 * Handles mouse up events. The event is delegated to the
		 * currently active tool.
		 * @@return whether the event was handled.
		 */
		public void mouseReleased(MouseEvent e) {
			Point p = constrainPoint(new Point(e.getX(), e.getY()));
			tool().mouseUp(e, p.x, p.y);
			checkDamage();
		}
	};
d158 3
a160 11
	MouseMotionListener mml = new MouseMotionListener() {
		/**
		 * Handles mouse drag events. The event is delegated to the
		 * currently active tool.
		 * @@return whether the event was handled.
		 */
		public void mouseDragged(MouseEvent e) {
			Point p = constrainPoint(new Point(e.getX(), e.getY()));
			tool().mouseDrag(e, p.x, p.y);
			checkDamage();
		}
d162 6
a167 9
		/**
		 * Handles mouse move events. The event is delegated to the
		 * currently active tool.
		 * @@return whether the event was handled.
		 */
		public void mouseMoved(MouseEvent e) {
			tool().mouseMove(e, e.getX(), e.getY());
		}
	};
d194 1
a194 1
		if (fDrawing != null) {
d196 1
a196 1
			fDrawing.removeDrawingChangeListener(this);
d200 2
a201 2
		if (fDrawing != null) {
			fDrawing.addDrawingChangeListener(this);
d253 1
a253 1
	  return false;    
d257 1
a257 1
	 * Inserts a vector of figures and translates them by the
d267 1
a267 1
	
d270 1
a270 1
	
d284 1
a284 1
	
d286 1
a286 1
	  
d288 1
a288 1
			ConnectionFigure cf = (ConnectionFigure) ecf.nextFigure();      
d298 1
a298 1
					Point ep = ef.center();            
d301 1
a301 1
		
d308 1
a308 1
		
d315 1
a315 1
		
d327 1
a327 1
		
d337 1
a337 1
		
d340 1
a340 1
		  
d587 1
a587 1
		// constrin to view size
a599 54
	/**
	 * Handles key down events. Cursor keys are handled
	 * by the view the other key events are delegated to the
	 * currently active tool.
	 * @@return whether the event was handled.
	 */
	public void keyPressed(KeyEvent e) {
		int code = e.getKeyCode();
		if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {
			Command cmd = new DeleteCommand("Delete", editor());
//			cmd.viewSelectionChanged(this);
			if(cmd.isExecutable()) {
				cmd.execute();
			}
		}
		else if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_UP ||
			code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_LEFT) {
			handleCursorKey(code);
		}
		else {
			tool().keyDown(e, code);
		}
		checkDamage();
	}

	/**
	 * Handles cursor keys by moving all the selected figures
	 * one grid point in the cursor direction.
	 */
	protected void handleCursorKey(int key) {
		int dx = 0, dy = 0;
		int stepX = 1, stepY = 1;
		// should consider Null Object.
		if (fConstrainer != null) {
			stepX = fConstrainer.getStepX();
			stepY = fConstrainer.getStepY();
		}

		switch (key) {
		case KeyEvent.VK_DOWN:
			dy = stepY;
			break;
		case KeyEvent.VK_UP:
			dy = -stepY;
			break;
		case KeyEvent.VK_RIGHT:
			dx = stepX;
			break;
		case KeyEvent.VK_LEFT:
			dx = -stepX;
			break;
		}
		moveSelection(dx, dy);
	}
d660 1
a660 1
		if (fBackgrounds != null && !isPrinting) {
d664 1
a664 1
		if (fForegrounds != null && !isPrinting) {
d681 1
a681 1
		if (fBackgrounds != null && !isPrinting) {
d684 2
a685 2
		fDrawing.draw(g, fe);
		if (fForegrounds != null && !isPrinting) {
d707 1
a707 1
		fDrawing.draw(g);
d790 2
a791 2
		if (fDrawing != null) {
			fDrawing.addDrawingChangeListener(this);
d818 1
a818 1
	
d866 1
a866 1
	
d870 1
a870 1
	
d873 113
@


1.7
log
@merge dnd (before 5.3)
@
text
@a186 1
		   // System.out.println("dragging " + myid);
a197 1
		  //  System.out.println("moved " + myid);
d523 5
a527 1
		Figure figure;
d529 3
a531 4
		FigureEnumeration k = selectionElements();

		while (k.hasMoreElements()) {
			k.nextFigure().invalidate();
@


1.6
log
@before merge for version 5.3 (dnd, undo,...) - 2
@
text
@d14 1
a21 1
import CH.ifa.draw.figures.TextTool;
d34 4
a37 12
        extends JPanel
        implements DrawingView,
                   MouseListener,
                   MouseMotionListener,
                   KeyListener {

    /**
     * The DrawingEditor of the view.
     * @@see #tool
     * @@see #setStatus
     */
    transient private DrawingEditor   fEditor;
d39 8
a46 1
    /**
d51 30
a80 55
    /**
     * The shown drawing.
     */
    private Drawing         fDrawing;

    /**
     * the accumulated damaged area
     */
    private transient Rectangle fDamage = null;

    /**
     * The list of currently selected figures.
     */
    transient private Vector fSelection;

    /**
     * The shown selection handles.
     */
    transient private Vector fSelectionHandles;

    /**
     * The preferred size of the view
     */
    private Dimension fViewSize;

    /**
     * The position of the last mouse click
     * inside the view.
     */
    private Point fLastClick;

    /**
     * A vector of optional backgrounds. The vector maintains
     * a list a view painters that are drawn before the contents,
     * that is in the background.
     */
    private Vector fBackgrounds = null;

    /**
     * A vector of optional foregrounds. The vector maintains
     * a list a view painters that are drawn after the contents,
     * that is in the foreground.
     */
    private Vector fForegrounds = null;

    /**
     * The update strategy used to repair the view.
     */
    private Painter fUpdateStrategy;

    /**
     * The grid used to constrain points for snap to
     * grid functionality.
     */
    private PointConstrainer fConstrainer;
d83 42
a124 1
	 *
d126 3
a128 1
	private transient UndoManager myUndoManager;
d130 5
a134 26
    /**
     * Scrolling increment
     */
    public static final int MINIMUM_WIDTH = 400;
    public static final int MINIMUM_HEIGHT = 300;
    public static final int SCROLL_INCR = 100;
    public static final int SCROLL_OFFSET = 10;
     
    /*
     * Serialization support. In JavaDraw only the Drawing is serialized.
     * However, for beans support StandardDrawingView supports
     * serialization
     */
    private static final long serialVersionUID = -3878153366174603336L;
    private int drawingViewSerializedDataVersion = 1;

    /**
     * Constructs the view.
     */
    public StandardDrawingView(DrawingEditor editor) {
        this(editor, MINIMUM_WIDTH, MINIMUM_HEIGHT);
    }
    
    public StandardDrawingView(DrawingEditor editor, int width, int height) {
        fEditor = editor;
        fViewSize = new Dimension(width,height);
d137 13
a149 238
        fLastClick = new Point(0, 0);
        fConstrainer = null;
        fSelection = new Vector();
        setUndoManager(new UndoManager());
        // JFC/Swing uses double buffering automatically as default
        setDisplayUpdate(new SimpleUpdateStrategy());
        // TODO: Test FastBufferedUpdateStrategy with JFC/Swing double buffering
        //setDisplayUpdate(new FastBufferedUpdateStrategy());
        setBackground(Color.lightGray);

        addMouseListener(this);
        addMouseMotionListener(this);
        addKeyListener(this);
    }

    /**
     * Sets the view's editor.
     */
    public void setEditor(DrawingEditor editor) {
        fEditor = editor;
    }

    /**
     * Gets the current tool.
     */
    public Tool tool() {
        return editor().tool();
    }

    /**
     * Gets the drawing.
     */
    public Drawing drawing() {
        return fDrawing;
    }

    /**
     * Sets and installs another drawing in the view.
     */
    public void setDrawing(Drawing d) {
        if (fDrawing != null) {
            clearSelection();
            fDrawing.removeDrawingChangeListener(this);
        }

        fDrawing = d;
        if (fDrawing != null) {
            fDrawing.addDrawingChangeListener(this);
        }

        checkMinimumSize();
        repaint();
    }

    /**
     * Gets the editor.
     */
    public DrawingEditor editor() {
        return fEditor;
    }

    /**
     * Automatically adjusts the size of view (optionally) and
     * scroll the invalidated rectangle to be visible in viewport
     * Params r - Rectangle to be scrolled
     *        bSizeChange - If true, view may be resized to accomodate "r".
     */     
    protected void scrollToVisible(Rectangle r, boolean bSizeChange) {
        if (bSizeChange) {
            // Flag for size change
            boolean bChanged = false;
            
            // New width and height
            int newWidth  = r.x + r.width  + SCROLL_INCR;
            int newHeight = r.y + r.height + SCROLL_INCR;
      
            // Check the adjustments in size
            if (newWidth > fViewSize.width) {
                fViewSize.width = newWidth;
                bChanged = true;
            }
            
            if (newHeight > fViewSize.height) {
                fViewSize.height = newHeight;
                bChanged = true;
            }
      
            // Auto size
            if (bChanged) {
                setSize(fViewSize);
            }
        }
      
        // Compute intersection of view size and to be scrolled rectangle
        // in order to prevent scrolling beyond view size
        scrollRectToVisible(r.intersection(new Rectangle(0, 0, fViewSize.width, fViewSize.height)));
    }
    
    /**
     * Adds a figure to the drawing.
     * @@return the added figure.
     */
    public Figure add(Figure figure) {
        Figure f = drawing().add(figure);
        
        // If new figure is added, check for size and scrolling
        if(f != null) {
            Rectangle r = f.displayBox();
            scrollToVisible(r, true);
        }

        return f;
    }

    /**
     * Removes a figure from the drawing.
     * @@return the removed figure
     */
    public Figure remove(Figure figure) {
        return drawing().remove(figure);
    }

    /**
     * Adds a vector of figures to the drawing.
     */
    public void addAll(Vector figures) {
        FigureEnumeration k = new FigureEnumerator(figures);
        while (k.hasMoreElements()) {
            add(k.nextFigure());
        }
    }

    /**
     * Check existance of figure in the drawing
     */
    public boolean figureExists(Figure inf, FigureEnumeration e) {
        while(e.hasMoreElements()) {
            Figure figure = e.nextFigure();

            if(figure.includes(inf)) {
                return true;
            }
        }

      return false;    
    }

    /**
     * Inserts a vector of figures and translates them by the
     * given offset. This function is used to insert figures from clipboards (cut/copy)
     *
     * @@return enumeration which has been added to the drawing. The figures in the enumeration
     *         can have changed during adding them (e.g. they could have been decorated).
     */
    public FigureEnumeration insertFigures(FigureEnumeration fe, int dx, int dy, boolean bCheck) {
        if (fe == null) {
            return FigureEnumerator.getEmptyEnumeration();
        }
    
    	Vector addedFigures = new Vector();
        Vector vCF = new Vector(10);
    
        while (fe.hasMoreElements()) {
            Figure figure = fe.nextFigure();
            if (figure instanceof ConnectionFigure) {
                vCF.addElement(figure);
            }
            else if (figure != null) {
                figure.moveBy(dx, dy);
                figure = add(figure);
                addToSelection(figure);
	            // figure might has changed during adding so add it afterwards
	            addedFigures.addElement(figure);
            }
        }
    
        FigureEnumeration ecf = new FigureEnumerator(vCF);
      
        while (ecf.hasMoreElements()) {
            ConnectionFigure cf = (ConnectionFigure) ecf.nextFigure();      
            Figure sf = cf.startFigure();
            Figure ef = cf.endFigure();

            if (figureExists(sf, drawing().figures()) &&
                figureExists(ef, drawing().figures()) &&
                (!bCheck || cf.canConnect(sf, ef))) {

                if (bCheck) {
                    Point sp = sf.center();
                    Point ep = ef.center();            
                    Connector fStartConnector = cf.startFigure().connectorAt(ep.x, ep.y);
                    Connector fEndConnector = cf.endFigure().connectorAt(sp.x, sp.y);
        
                    if (fEndConnector != null && fStartConnector != null) {
                        cf.connectStart(fStartConnector);
                        cf.connectEnd(fEndConnector);
                        cf.updateConnection();
                    }
                }
        
                Figure nf = add(cf);
                addToSelection(nf);
	            // figure might has changed during adding so add it afterwards
	            addedFigures.addElement(nf);
            }
        }
        
        return new FigureEnumerator(addedFigures);
    }

    /**
     * Returns a vector of connectionfigures attached to this figure
     */
    public Vector getConnectionFigures(Figure inFigure) {
        // If no figure or figure is non connectable, just return null
        if (inFigure == null || !inFigure.canConnect()) {
            return null;
        }
        
        // if (inFigure instanceof ConnectionFigure)
        //  return null;

        Vector result = new Vector(5);
        FigureEnumeration figures = drawing().figures();

        // Find all connection figures
        while (figures.hasMoreElements()) {
            Figure f= figures.nextFigure();
        
            if ((f instanceof ConnectionFigure) && !(isFigureSelected(f))) {
                ConnectionFigure cf = (ConnectionFigure) f;
          
                if (cf.startFigure().includes(inFigure) ||
                    cf.endFigure().includes(inFigure)) {
                    result.addElement(f);
                }
            }
        }
d151 233
a383 1
        return result;
d386 72
a457 72
    /**
     * Gets the minimum dimension of the drawing.
     */
    public Dimension getMinimumSize() {
        return fViewSize;
    }

    /**
     * Gets the preferred dimension of the drawing..
     */
    public Dimension getPreferredSize() {
        return getMinimumSize();
    }

    /**
     * Sets the current display update strategy.
     * @@see Painter
     */
    public void setDisplayUpdate(Painter updateStrategy) {
        fUpdateStrategy = updateStrategy;
    }

    /**
     * Sets the current display update strategy.
     * @@see Painter
     */
    public Painter getDisplayUpdate() {
        return fUpdateStrategy;
    }

    /**
     * Gets the currently selected figures.
     * @@return a vector with the selected figures. The vector
     * is a copy of the current selection.
     */
    public Vector selection() {
        // protect the vector with the current selection
        return (Vector)fSelection.clone();
    }

    /**
     * Gets an enumeration over the currently selected figures.
     */
    public FigureEnumeration selectionElements() {
        return new FigureEnumerator(selectionZOrdered());
    }

    /**
     * Gets the currently selected figures in Z order.
     * @@see #selection
     * @@return a vector with the selected figures. The vector
     * is a copy of the current selection.
     */
    public Vector selectionZOrdered() {
        Vector result = new Vector(selectionCount());
        FigureEnumeration figures = drawing().figures();

        while (figures.hasMoreElements()) {
            Figure f= figures.nextFigure();
            if (isFigureSelected(f)) {
                result.addElement(f);
            }
        }
        return result;
    }

    /**
     * Gets the number of selected figures.
     */
    public int selectionCount() {
        return fSelection.size();
    }
d466 120
a585 120
    /**
     * Adds a figure to the current selection. The figure is only selected if
     * it is also contained in the Drawing associated with this DrawingView.
     */
    public void addToSelection(Figure figure) {
        if (!isFigureSelected(figure) && drawing().includes(figure)) {
            fSelection.addElement(figure);
            fSelectionHandles = null;
            figure.invalidate();
            fireSelectionChanged();
        }
    }

    /**
     * Adds a vector of figures to the current selection.
     */
    public void addToSelectionAll(Vector figures) {
        addToSelectionAll(new FigureEnumerator(figures));
    }

    /**
     * Adds a FigureEnumeration to the current selection.
     */
    public void addToSelectionAll(FigureEnumeration fe) {
        while (fe.hasMoreElements()) {
            addToSelection(fe.nextFigure());
        }
    }

    /**
     * Removes a figure from the selection.
     */
    public void removeFromSelection(Figure figure) {
        if (isFigureSelected(figure)) {
            fSelection.removeElement(figure);
            fSelectionHandles = null;
            figure.invalidate();
            fireSelectionChanged();
        }
    }

    /**
     * If a figure isn't selected it is added to the selection.
     * Otherwise it is removed from the selection.
     */
    public void toggleSelection(Figure figure) {
        if (isFigureSelected(figure)) {
            removeFromSelection(figure);
        }
        else {
            addToSelection(figure);
        }
        fireSelectionChanged();
    }

    /**
     * Clears the current selection.
     */
    public void clearSelection() {
        Figure figure;

        FigureEnumeration k = selectionElements();

        while (k.hasMoreElements()) {
            k.nextFigure().invalidate();
        }
        fSelection = new Vector();
        fSelectionHandles = null;
        fireSelectionChanged();
    }

    /**
     * Gets an enumeration of the currently active handles.
     */
    private Enumeration selectionHandles() {
        if (fSelectionHandles == null) {
            fSelectionHandles = new Vector();
            FigureEnumeration k = selectionElements();
            while (k.hasMoreElements()) {
                Figure figure = k.nextFigure();
                Enumeration kk = figure.handles().elements();
                while (kk.hasMoreElements()) {
                    fSelectionHandles.addElement(kk.nextElement());
                }
            }
        }
        return fSelectionHandles.elements();
    }

    /**
     * Gets the current selection as a FigureSelection. A FigureSelection
     * can be cut, copied, pasted.
     */
    public FigureSelection getFigureSelection() {
        return new StandardFigureSelection(new FigureEnumerator(selectionZOrdered()), selectionCount());
    }

    /**
     * Finds a handle at the given coordinates.
     * @@return the hit handle, null if no handle is found.
     */
    public Handle findHandle(int x, int y) {
        Handle handle;

        Enumeration k = selectionHandles();
        while (k.hasMoreElements()) {
            handle = (Handle) k.nextElement();
            if (handle.containsPoint(x, y)) {
                return handle;
            }
        }
        return null;
    }

    /**
     * Informs that the current selection changed.
     * By default this event is forwarded to the
     * drawing editor.
     */
    protected void fireSelectionChanged() {
d592 8
a599 1
    }
d601 127
a727 195
    /**
     * Gets the position of the last click inside the view.
     */
    public Point lastClick() {
        return fLastClick;
    }

    /**
     * Sets the grid spacing that is used to constrain points.
     */
    public void setConstrainer(PointConstrainer c) {
        fConstrainer = c;
    }

    /**
     * Gets the current constrainer.
     */
    public PointConstrainer getConstrainer() {
        return fConstrainer;
    }

    /**
     * Constrains a point to the current grid.
     */
    protected Point constrainPoint(Point p) {
        // constrin to view size
        Dimension size = getSize();
        //p.x = Math.min(size.width, Math.max(1, p.x));
        //p.y = Math.min(size.height, Math.max(1, p.y));
        p.x = Geom.range(1, size.width, p.x);
        p.y = Geom.range(1, size.height, p.y);

        if (fConstrainer != null ) {
            return fConstrainer.constrainPoint(p);
        }
        return p;
	}

    /**
     * Handles mouse down events. The event is delegated to the
     * currently active tool.
     * @@return whether the event was handled.
     */
    public void mousePressed(MouseEvent e) {
        requestFocus(); // JDK1.1
        Point p = constrainPoint(new Point(e.getX(), e.getY()));
        fLastClick = new Point(e.getX(), e.getY());
        tool().mouseDown(e, p.x, p.y);
        checkDamage();
    }

    /**
     * Handles mouse drag events. The event is delegated to the
     * currently active tool.
     * @@return whether the event was handled.
     */
    public void mouseDragged(MouseEvent e) {
        Point p = constrainPoint(new Point(e.getX(), e.getY()));
        tool().mouseDrag(e, p.x, p.y);
        checkDamage();
    }

    /**
     * Handles mouse move events. The event is delegated to the
     * currently active tool.
     * @@return whether the event was handled.
     */
    public void mouseMoved(MouseEvent e) {
        tool().mouseMove(e, e.getX(), e.getY());
    }

    /**
     * Handles mouse up events. The event is delegated to the
     * currently active tool.
     * @@return whether the event was handled.
     */
    public void mouseReleased(MouseEvent e) {
        Point p = constrainPoint(new Point(e.getX(), e.getY()));
        tool().mouseUp(e, p.x, p.y);
        checkDamage();
    }

    /**
     * Handles key down events. Cursor keys are handled
     * by the view the other key events are delegated to the
     * currently active tool.
     * @@return whether the event was handled.
     */
    public void keyPressed(KeyEvent e) {
        int code = e.getKeyCode();
        if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {
            Command cmd = new DeleteCommand("Delete", this);
            cmd.execute();
        }
        else if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_UP ||
            code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_LEFT) {
            handleCursorKey(code);
        }
        else {
            tool().keyDown(e, code);
        }
        checkDamage();
    }

    /**
     * Handles cursor keys by moving all the selected figures
     * one grid point in the cursor direction.
     */
    protected void handleCursorKey(int key) {
        int dx = 0, dy = 0;
        int stepX = 1, stepY = 1;
        // should consider Null Object.
        if (fConstrainer != null) {
            stepX = fConstrainer.getStepX();
            stepY = fConstrainer.getStepY();
        }

        switch (key) {
        case KeyEvent.VK_DOWN:
            dy = stepY;
            break;
        case KeyEvent.VK_UP:
            dy = -stepY;
            break;
        case KeyEvent.VK_RIGHT:
            dx = stepX;
            break;
        case KeyEvent.VK_LEFT:
            dx = -stepX;
            break;
        }
        moveSelection(dx, dy);
    }

    private void moveSelection(int dx, int dy) {
        FigureEnumeration figures = selectionElements();
        while (figures.hasMoreElements()) {
            figures.nextFigure().moveBy(dx, dy);
        }
        checkDamage();
    }

    /**
     * Determines whether to auto scroll damaged rectangle.
     * Override if you do not want drag scroll mechanism.
     * By default this method returns true.
     */
    protected boolean doDragScroll() {
        return true;
    }
    
    /**
     * Refreshes the drawing if there is some accumulated damage
     */
    public synchronized void checkDamage() {
        Enumeration each = drawing().drawingChangeListeners();
        while (each.hasMoreElements()) {
            Object l = each.nextElement();
            if (l instanceof DrawingView) {
                ((DrawingView)l).repairDamage();
            }
        }
    }

    public void repairDamage() {
        if (fDamage == null) {
//            repaint();
    	}
    	else {

// TextFigures have problems with scrolling: avoid scrolling them
// TextTool does not call checkDamage at the moment to avoid scrolling
//            if (doDragScroll() && !(tool() instanceof TextTool)) {
            if (doDragScroll() ) {
                scrollToVisible(fDamage, false);
            }

            repaint(1, fDamage.x, fDamage.y, fDamage.width, fDamage.height);
            fDamage = null;
        }
    }

    public void drawingInvalidated(DrawingChangeEvent e) {
        Rectangle r = e.getInvalidatedRectangle();
        if (fDamage == null) {
            fDamage = r;
        }
        else {
            fDamage.add(r);
        }
    }

    public void drawingRequestUpdate(DrawingChangeEvent e) {
        repairDamage();
    }
d738 26
a763 26
    /**
     * Draws the contents of the drawing view.
     * The view has three layers: background, drawing, handles.
     * The layers are drawn in back to front order.
     */
    public void drawAll(Graphics g) {
        boolean isPrinting = g instanceof PrintGraphics;
        drawBackground(g);
        if (fBackgrounds != null && !isPrinting) {
            drawPainters(g, fBackgrounds);
        }
        drawDrawing(g);
        if (fForegrounds != null && !isPrinting) {
            drawPainters(g, fForegrounds);
        }
        if (!isPrinting) {
            drawHandles(g);
        }
    }

    /**
     * Draws the given figures.
     * The view has three layers: background, drawing, handles.
     * The layers are drawn in back to front order.
     * No background is drawn.
     */
d765 114
a878 114
        boolean isPrinting = g instanceof PrintGraphics;
        //drawBackground(g);
        if (fBackgrounds != null && !isPrinting) {
            drawPainters(g, fBackgrounds);
        }
        fDrawing.draw(g, fe);
        if (fForegrounds != null && !isPrinting) {
            drawPainters(g, fForegrounds);
        }
        if (!isPrinting) {
            drawHandles(g);
        }
    }

    /**
     * Draws the currently active handles.
     */
    public void drawHandles(Graphics g) {
        Enumeration k = selectionHandles();
        while (k.hasMoreElements()) {
            ((Handle) k.nextElement()).draw(g);
        }
    }

    /**
     * Draws the drawing.
     */
    public void drawDrawing(Graphics g) {
        fDrawing.draw(g);
    }

    /**
     * Draws the background. If a background pattern is set it
     * is used to fill the background. Otherwise the background
     * is filled in the background color.
     */
    public void drawBackground(Graphics g) {
        g.setColor(getBackground());
        g.fillRect(0, 0, getBounds().width, getBounds().height);
    }

    private void drawPainters(Graphics g, Vector v) {
        for (int i = 0; i < v.size(); i++) {
            ((Painter)v.elementAt(i)).draw(g, this);
        }
    }

    /**
     * Adds a background.
     */
    public void addBackground(Painter painter)  {
        if (fBackgrounds == null) {
            fBackgrounds = new Vector(3);
        }
        fBackgrounds.addElement(painter);
        repaint();
    }

    /**
     * Removes a background.
     */
    public void removeBackground(Painter painter)  {
        if (fBackgrounds != null) {
            fBackgrounds.removeElement(painter);
        }
        repaint();
    }

    /**
     * Removes a foreground.
     */
    public void removeForeground(Painter painter)  {
        if (fForegrounds != null) {
            fForegrounds.removeElement(painter);
        }
        repaint();
    }

    /**
     * Adds a foreground.
     */
    public void addForeground(Painter painter)  {
        if (fForegrounds == null) {
            fForegrounds = new Vector(3);
        }
        fForegrounds.addElement(painter);
        repaint();
    }

    /**
     * Freezes the view by acquiring the drawing lock.
     * @@see Drawing#lock
     */
    public void freezeView() {
        drawing().lock();
    }

    /**
     * Unfreezes the view by releasing the drawing lock.
     * @@see Drawing#unlock
     */
    public void unfreezeView() {
        drawing().unlock();
    }

    private void readObject(ObjectInputStream s)
        throws ClassNotFoundException, IOException {

        s.defaultReadObject();

        fSelection = new Vector(); // could use lazy initialization instead
        if (fDrawing != null) {
            fDrawing.addDrawingChangeListener(this);
        }
d880 16
a895 1
    }
d897 10
a906 25
    private void checkMinimumSize() {
        FigureEnumeration k = drawing().figures();
        Dimension d = new Dimension(0, 0);
        while (k.hasMoreElements()) {
            Rectangle r = k.nextFigure().displayBox();
            d.width = Math.max(d.width, r.x+r.width);
            d.height = Math.max(d.height, r.y+r.height);
        }
        if (fViewSize.height < d.height || fViewSize.width < d.width) {
            fViewSize.height = d.height + SCROLL_OFFSET;
            fViewSize.width = d.width + SCROLL_OFFSET;
            setSize(fViewSize);
        }
    }

    public boolean isFocusTraversable() {
        return true;
    }

    // listener methods we are not interested in
    public void mouseEntered(MouseEvent e) {}
    public void mouseExited(MouseEvent e) {}
    public void mouseClicked(MouseEvent e) {}
    public void keyTyped(KeyEvent e) {}
    public void keyReleased(KeyEvent e) {}
d924 27
a950 2
	protected void setUndoManager(UndoManager newUndoManager) {
		myUndoManager = newUndoManager;
d953 2
a954 2
	public UndoManager getUndoManager() {
		return myUndoManager;
d956 3
@


1.5
log
@before merge for version 5.3 (dnd, undo,...)
@
text
@d2 1
a2 1
 * @@(#)StandardDrawingView.java 5.2
d4 6
d21 1
d25 1
d29 2
d48 5
d108 13
d132 4
d139 2
d144 1
d167 1
a167 1
        return fEditor.tool();
d203 37
d244 9
a252 1
        return drawing().add(figure);
d268 1
a268 1
        while (k.hasMoreElements())
d270 79
d352 32
d406 8
d427 1
a427 1
        return new FigureEnumerator(fSelection);
d437 1
a437 1
        Vector result = new Vector(fSelection.size());
d442 1
a442 1
            if (fSelection.contains(f)) {
d456 7
d464 2
a465 1
     * Adds a figure to the current selection.
d468 1
a468 1
        if (!fSelection.contains(figure)) {
d472 1
a472 1
            selectionChanged();
d480 10
a489 3
        FigureEnumeration k = new FigureEnumerator(figures);
        while (k.hasMoreElements())
            addToSelection(k.nextFigure());
d496 1
a496 1
        if (fSelection.contains(figure)) {
d500 1
a500 1
            selectionChanged();
d509 1
a509 1
        if (fSelection.contains(figure))
d511 2
a512 1
        else
d514 2
a515 1
        selectionChanged();
d526 1
a526 1
        while (k.hasMoreElements())
d528 1
d531 1
a531 1
        selectionChanged();
d544 1
a544 1
                while (kk.hasMoreElements())
d546 1
d557 1
a557 1
        return new FigureSelection(selectionZOrdered());
d570 1
a570 1
            if (handle.containsPoint(x, y))
d572 1
d582 7
a588 2
    protected void selectionChanged() {
        fEditor.selectionChanged(this);
d623 1
a623 1
        if (fConstrainer != null )
d625 1
d684 2
a685 1
        } else if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_UP ||
d688 2
a689 1
        } else {
a724 1

d727 1
a727 1
        while (figures.hasMoreElements())
d729 1
d734 9
d756 13
a768 2
        if (fDamage != null) {
            repaint(fDamage.x, fDamage.y, fDamage.width, fDamage.height);
d775 1
a775 1
        if (fDamage == null)
d777 2
a778 1
        else
d780 1
d787 8
a794 15
    /**
     * Updates the drawing view.
     */
    public void update(Graphics g) {
        paint(g);
    }

    /**
     * Paints the drawing view. The actual drawing is delegated to
     * the current update strategy.
     * @@see Painter
     */
    public void paint(Graphics g) {
        fUpdateStrategy.draw(g, this);
    }
d804 1
a804 1
        if (fBackgrounds != null && !isPrinting)
d806 1
d808 1
a808 1
        if (fForegrounds != null && !isPrinting)
d810 2
a811 1
        if (!isPrinting)
d813 1
d825 1
a825 1
        if (fBackgrounds != null && !isPrinting)
d827 1
d829 1
a829 1
        if (fForegrounds != null && !isPrinting)
d831 2
a832 1
        if (!isPrinting)
d834 1
d842 1
a842 1
        while (k.hasMoreElements())
d844 1
d865 1
a865 1
        for (int i = 0; i < v.size(); i++)
d867 1
d874 1
a874 1
        if (fBackgrounds == null)
d876 1
d885 1
a885 1
        if (fBackgrounds != null)
d887 1
d895 1
a895 1
        if (fForegrounds != null)
d897 1
d905 1
a905 1
        if (fForegrounds == null)
d907 1
d934 1
a934 1
        if (fDrawing != null)
d936 2
d949 2
a950 2
            fViewSize.height = d.height+10;
            fViewSize.width = d.width+10;
d965 24
@


1.4
log
@- SelectionFigure is now an interface. The default implementation CH.ifa.draw.standard.StandardSelectionFigure
- A FigureSelectionListener interface has been introduced in CH.ifa.draw.framework. An DrawingEditor
  is now a FigureSelectionListener and the signature for all selectionChanged() methods has been
  changed to figureSelectionChanged().
- CH.ifa.draw.util.Command is now an interface. A AbstractCommand can be found in CH.ifa.draw.standard.
- All commands used to have a fView field. This has been moved to CH.ifa.draw.standard.AbstactCommand
- A CH.ifa.draw.standard.StandardDrawingView has now a paintComponents() method instead of a paint()
  and update() method. This allows the CH.ifa.draw.util.FloatingTextField to be a javax.swing.JTextField
  instead of a java.awt.TextField.
- CH.ifa.draw.figures.AbstractLineDecorator has been missing
- DrawApplet, DrawApplication and derived classes are now programmed towards the DrawingView interface
  instead of using StandardDrawingView. That leads to occasional cast when some additional StandardDrawingView
  functionality is required in some specialized cases. Applications that were derived from DrawApplication
  and used to override the createContents() methods should now return a DrawingView as well
@
text
@a37 5
	 * the registered listeners for selection changes
	 */
	private transient Vector fSelectionListeners;
	
    /**
a106 2
		fSelectionListeners = new Vector();
		addFigureSelectionListener(editor());
d132 1
a132 1
        return editor().tool();
a214 8
     * Sets the current display update strategy.
     * @@see Painter
     */
    public Painter getDisplayUpdate() {
        return fUpdateStrategy;
    }

    /**
d265 1
a265 1
            fireSelectionChanged();
d286 1
a286 1
            fireSelectionChanged();
d299 1
a299 1
        fireSelectionChanged();
d314 1
a314 1
        fireSelectionChanged();
d339 1
a339 1
        return new StandardFigureSelection(selectionZOrdered());
d363 2
a364 7
    protected void fireSelectionChanged() {
		if (fSelectionListeners != null) {
			for (int i = 0; i < fSelectionListeners.size(); i++) {
				FigureSelectionListener l = (FigureSelectionListener)fSelectionListeners.elementAt(i);
				l.figureSelectionChanged(this);
    }
		}
d498 1
d538 15
a552 8
	/**
	 * Paints the drawing view. The actual drawing is delegated to
	 * the current update strategy.
	 * @@see Painter
	 */
	protected void paintComponent(Graphics g) {
		getDisplayUpdate().draw(g, this);
	}
a681 1
		fSelectionListeners= new Vector();
a708 16

	/**
	 * Add a listener for selection changes.
	 * @@param fsl jhotdraw.framework.FigureSelectionListener
	 */
	public void addFigureSelectionListener(FigureSelectionListener fsl) {
		fSelectionListeners.add(fsl);
	}

	/**
	 * Remove a listener for selection changes.
	 * @@param fsl jhotdraw.framework.FigureSelectionListener
	 */
	public void removeFigureSelectionListener(FigureSelectionListener fsl) {
		fSelectionListeners.remove(fsl);
	}
@


1.3
log
@Merge to JHotDraw 5.2 (using JFC/Swing GUI components)
@
text
@d38 5
d112 2
d139 1
a139 1
        return fEditor.tool();
d222 8
d280 1
a280 1
            selectionChanged();
d301 1
a301 1
            selectionChanged();
d314 1
a314 1
        selectionChanged();
d329 1
a329 1
        selectionChanged();
d354 1
a354 1
        return new FigureSelection(selectionZOrdered());
d378 7
a384 2
    protected void selectionChanged() {
        fEditor.selectionChanged(this);
a517 1

d557 8
a564 15
    /**
     * Updates the drawing view.
     */
    public void update(Graphics g) {
        paint(g);
    }

    /**
     * Paints the drawing view. The actual drawing is delegated to
     * the current update strategy.
     * @@see Painter
     */
    public void paint(Graphics g) {
        fUpdateStrategy.draw(g, this);
    }
d694 1
d722 16
@


1.2
log
@use new update strategy; use 3 layers for painting
@
text
@d2 1
a2 1
 * @@(#)StandardDrawingView.java 5.1
d8 1
d24 1
a24 1
        extends Panel
d110 4
a113 1
        setDisplayUpdate(new FastBufferedUpdateStrategy());
d146 2
a147 3
        clearSelection();

        if (fDrawing != null)
d149 1
d152 1
a152 1
        if (fDrawing != null)
d154 2
d208 1
a208 1
     * @@see UpdateStrategy
@


1.1
log
@Initial revision
@
text
@d109 1
a109 1
        setDisplayUpdate(new BufferedUpdateStrategy());
d559 18
@


1.1.1.1
log
@
Initial revision.
@
text
@@
